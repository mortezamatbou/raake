-- phpMyAdmin SQL Dump
-- version 4.6.0
-- http://www.phpmyadmin.net
--
-- Host: localhost:3306
-- Generation Time: Jun 17, 2018 at 01:00 AM
-- Server version: 10.1.9-MariaDB-log
-- PHP Version: 5.6.16

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `raake`
--

-- --------------------------------------------------------

--
-- Table structure for table `answer`
--

CREATE TABLE `answer` (
  `answer_id` int(11) NOT NULL,
  `comment_id` int(11) NOT NULL,
  `answer_content` text COLLATE utf8_persian_ci NOT NULL,
  `answer_author` int(11) NOT NULL,
  `answer_date` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `answer`
--

INSERT INTO `answer` (`answer_id`, `comment_id`, `answer_content`, `answer_author`, `answer_date`) VALUES
(1, 2, 'پاسخ گویی به کامنت برای آزمایش می باشد و معنی و مفهوم خاصی ندارد', 22546897, '2017-10-02 13:26:34'),
(2, 6, 'پاسخ گویی به کامنت برای آزمایش می باشد و معنی و مفهوم خاصی ندارد', 22546897, '2018-02-12 15:57:13'),
(3, 8, 'پاسخ گویی به کامنت برای آزمایش می باشد و معنی و مفهوم خاصی ندارد', 22546897, '2018-05-16 01:56:48');

-- --------------------------------------------------------

--
-- Table structure for table `articles`
--

CREATE TABLE `articles` (
  `article_id` int(11) NOT NULL,
  `article_title` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `article_precontent` varchar(255) COLLATE utf8_persian_ci NOT NULL,
  `article_keywords` varchar(230) COLLATE utf8_persian_ci DEFAULT NULL,
  `article_content` longtext COLLATE utf8_persian_ci NOT NULL,
  `article_date` datetime NOT NULL,
  `article_author` int(11) NOT NULL,
  `article_thumbnail` varchar(100) COLLATE utf8_persian_ci DEFAULT 'nopic.png',
  `article_category` int(11) NOT NULL,
  `article_view` int(11) NOT NULL DEFAULT '0',
  `article_status` tinyint(4) NOT NULL DEFAULT '1',
  `article_last_modified` datetime NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `articles`
--

INSERT INTO `articles` (`article_id`, `article_title`, `article_precontent`, `article_keywords`, `article_content`, `article_date`, `article_author`, `article_thumbnail`, `article_category`, `article_view`, `article_status`, `article_last_modified`) VALUES
(120, 'مقدمات زبان جاوا', 'اولین قسمت برنامه نویسی جاوا و آموزش اصول اولیه برنامه نویسی و جاوا', 'article,article keywords,article keywords2,keywords2', '<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h1>آموزش زبان برنامه نویسی جاوا و مقدمات آن</h1>\n<p>&nbsp;</p>\n<h2>زبان کامپیوتر</h2>\n<p>کامپیوتر یک دستگاه الکترونیکی است.سیگنال های الکترونیکی در داخل کامپیوتر از کانال&zwnj;هایی عبور می کنند.<br />دو سیگنال کامپیوتری وجود دارد :</p>\n<p>۱- سیگنال های آنالوگ<br />۲- سیگنال های دیجیتال</p>\n<p><strong>سیگنال های آنالوگ</strong> شکل موج&zwnj;های پیوسته ایی هستند که برای نمایش چیز هایی مثل صدا استفاده می شود.<br /><strong>سیگنال های دیجیتال</strong> اطلاعات را با دنباله ایی از صفر ها و یک ها نمایش می دهند. ۰ نماینده ولتاژ پایین و ۱ نماینده ولتاژ بالا است.</p>\n<p>سیگنال های دیجیتال نسبت به سیگنال های آنالوگ حامل های قابل اعتمادتری برای اطلاعات هستند و می&zwnj;توانند با دقت کافی از دستگاهی به دستگاه دیگر انتقال پیدا کنند.<br />چون سیگنال های دیجیتال در کامپیوتر پردازش می&zwnj;شوند زبان کامپوتر به زیان ماشین دنباله ایی از ۰ ها و ۱ ها است.<br />رقم ۰ یا ۱ به نام رقم دودویی (binary) یا بیت (bit) خوانده می شود.<br />دنباله ایی از ۸ بیت بایت (byte) نام دارد.</p>\n<h2>جدول واحد های دودویی یا واحد های حافظه</h2>\n<p>&nbsp;</p>\n<table>\n<tbody>\n<tr>\n<td>واحد</td>\n<td>نماد</td>\n<td style="height: 13px;">بیت/بایت</td>\n</tr>\n<tr>\n<td>بایت</td>\n<td>-</td>\n<td>8 bits</td>\n</tr>\n<tr>\n<td>کیلوبایت</td>\n<td>KB</td>\n<td>2<sup>10</sup> bytes = 1024 bytes</td>\n</tr>\n<tr>\n<td>مگابایت</td>\n<td>MB</td>\n<td>1024 KB = 2<sup>10</sup>KB = 2<sup>20</sup>bytes = 1,048,576 bytes</td>\n</tr>\n<tr>\n<td>گیگابایت</td>\n<td>GB</td>\n<td>1024 MB = 2<sup>10</sup>MB = 2<sup>30</sup>bytes = 1,073,741,824 bytes</td>\n</tr>\n<tr>\n<td>ترابایت</td>\n<td>TB</td>\n<td>1024 TB = 2<sup>10</sup>GB = 2<sup>40</sup>bytes = 1,099,511,627,776 bytes</td>\n</tr>\n<tr>\n<td>پتابایت</td>\n<td>PB</td>\n<td>1024 TB = 2<sup>10</sup>TB = 2<sup>50</sup>bytes = 1,125,899,906,824,624 bytes</td>\n</tr>\n<tr>\n<td>اگزابایت</td>\n<td>EB</td>\n<td>1024 PB = 2<sup>10</sup>PB = 2<sup>60</sup>bytes = 1,152,921,504,606,846,976 bytes</td>\n</tr>\n<tr>\n<td>زتابایت</td>\n<td>ZB</td>\n<td>1024 EB = 2<sup>10</sup>EB = 2<sup>70</sup>bytes = 1,180,591,620,717,411,303,424 bytes</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>هر حرف یا عدد یا نماد خاصی (مثل * یا } ) روی صفحه&zwnj;کلید به صورت دنباله ایی از بیت&zwnj;ها رمز گذاری می&zwnj;شود و هرکدام نمایش یکتایی دارد. متداولترین رمزگذاری اَسکی (ASCII) است که مجموعه داده ایی آن شامل ۱۲۸ کاراکتر است که از ۰ تا ۱۲۷ شماره گذاری می شود.</p>\n<p><br />برای مثال کاراکتر اسکی \'A\' با 1000001 نمایش داده می شود. طرح رمزگذاری دیگر یونیکد (unicode) نام دارد که توسعه جدید محسوب می شود. Unicode دارای ۶۵۵۳۶ کاراکتر است و برای ذخیره کاراکتر آن به دو بایت (16 bit) نیاز است. جاوا از مجموعه کاراکتری unicode استفاده می کند. یعنی در جاوا هر کاراکتر به صورت دنباله ایی ۱۶ بیتی نمایش داده می شود. مثلاً کاراکتر \'A\' در unicode با 0000000001000001 نمایش داده می شود.</p>\n<p>کاراکتر ASCII زیر مجموعه unicode است. ۱۲۸ کاراکتر اول unicode مثل کاراکتر های ASCII است. <br />ساده&zwnj;ترین زبان کامپیوتر یعنی زبان ماشین دستورالعمل های برنامه را به صورت بیتی مشخص می کند. <br />کامپیوتر ها اغلب انواع یکسانی از عملیات را انجام می&zwnj;دهند اما طراحان CPU های مختلف مجموعه متفاوتی از کد های دودویی را برای نمایش و اجرای این عملیات فرآهم می سازند. <br />بنابر این زبان یک ماشین الزاماً مثل زبان ماشین کامپیوتر دیگر نیست. تنها سازگاری بین کامپیوتر ها این است که در هر کامپیوتر تمام داده&zwnj;ها به صورت کد هایی دودویی ذخیره و بازیابی می شوند.</p>\n<h2>&nbsp;</h2>\n<h2><strong>زبان اسمبلی</strong></h2>\n<p>با توضیحات بالا نوشتن برنامه به زبان ماشین بسیار دشوار است. و ممکن است برای کامپیوتر های مختلف متفاوت باشد.<br />بنابر این زبانی به نام اسمبلی ایجاد شد.(assembly language) تا کار برنامه نویسیان راحت&zwnj;تر شود.<br />در این زبان هر دستورالعمل به صورت یک نماد است. مثلاً برای</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>LOAD rate\nMULT hourse\nSTORE salary</code></pre>\n<p>&nbsp;</p>\n<p>این تکه کد می&zwnj;گوید مقدار rate را بارگذلری کن در مقدار hourse ضرب کن و نتیجه را در salary ذخیره کن. نوشتن برنامه به زبان اسمبلی به مراتب ساده&zwnj;تر از زبان ماشین است.</p>\n<p><strong>اسمبلر (assembler)</strong> برنامه ایی است که برنامه نوشته شده به زبان اسمبلی را به برنامه ی معادل در زبان ماشین تبدیل می کند.</p>\n<p><strong>زبان&zwnj;های سطح بالا (high level language)</strong></p>\n<p>مرحله بعدی زبان&zwnj;های سطح بالا هستند که دستور العمل ها در این زبان&zwnj;ها خیلی شبیه به محاوره در زبان انگلیسی است. نمونه ایی از زبان&zwnj;های سطح بالا می&zwnj;توان به BASIC, FORTRAN, COBOL, PASCAL, C C++ و JAVA اشاره کرد. فرمول محاسبه ایی که با اسمبلی نوشته شد به صورت زیر در زبان جاوا قابل پیاده&zwnj;سازی است<br /><br /></p>\n<pre class="language-java"><code>salary = rate * hourse</code></pre>\n<p>&nbsp;</p>\n<p>کامپیوتر ها نمی&zwnj;توانند مستقیماً دستورالعمل ها در حالت سطح بالا را اجرا کنند.<br />برای اینکه این دستور جاوا بتواند در کامپیوتر اجرا شود ابتدا باید به یک زبان میانی (intermediated language) به نام بایت کد (byte code) ترجمه شود و سپسبه زبان ماشین خاصی تفسیر (interpret) گردد.<br />برنامه ایی به نام کامپایلر (compiler) دستورالعمل های نوشته شده به زبان جاوا را به بایت کد تبدیل می کند. <br />JVM یا Java Virtual Machine</p>\n<p>چون کامپیوتر فقط زبان ماشین را درک می&zwnj;کند و CPU های مختلف زبان&zwnj;های ماشین مختلفی دارند و برای اینکه جاوا مستقل از محیط باشد یعنی با بایت کد برنامه در محیط های مختلف با CPU ها و زبان&zwnj;های ماشین مختلف کار کند طراحان جاوا یک کامپیوتر مجازی به نام ماشین مجازی جاوا JVM را طراحی کردن.<br />Byte code زبان ماشین برای JVM است.<br />بنابراین جاوا استقلال از محیط را با JVM انجام می دهد.</p>\n<h2>&nbsp;</h2>\n<h2><strong>جاوا و نحوه ی کارکرد آن</strong></h2>\n<p>یکی از بزرگترین امتیازها جاوا که باعث شهرت این زبان شده است عدم وابستگی آن به محیط برنامه نویسی است.یعنی برنامه&zwnj;های آن بدون تضییر در ویندوز مکینتاش و لینوکس و سایر محیط هایی که از جاوا پشتیبانی می&zwnj;کند اجرا می شود.ولی در زبان&zwnj;های کامپایلری دیگر برای محیط های مختلف باید نسخه های مختلف نوشته شود.<br />برای پی بردن به این ویژگی زبان برنامه نویسی C را در نظر بگیرید.<br />یک برنامه C توسط کامپایلر به زبان ماشین تبدیل می شود. یعنی به دستوراتی تبدیل می&zwnj;شود که مخصوص پردازنده آن ماشین است.</p>\n<p>اگر این برنامه در یک سیستم با پردازنده اینتل ترجمه شود در سایر سیستم&zwnj;های اینتل اجرا می&zwnj;شود ولی در ماشین&zwnj;های دیگر مانند مکینتاش اجرا نخواهد شد. برای استفاده برنامه در چنین ماشین&zwnj;هایی باید ابتدا کد منبع (source code) به آن ماشین انتقال یابد و برنامه دوباره کامپایل شود تا کدی برای آن ماشین تولید گردد. در بعضی از موارد نیز بسته به نوع پردازنده ها و عوامل دیگر source code باید تغییرات هم داشته باشد. جاوا این استقلال از محیط را با java virtual machine فراهم کرده است. <br />JVM یک کامپیوتر فرضی است. برنامه&zwnj;های کامپایل شده جاوا را می&zwnj;گیرد و دستورهای آن را برای سیستم عامل های مختلف تبدیل به فرمان&zwnj;هایی می&zwnj;کند که برای آن&zwnj;ها قابل استفاده باشد. برنامه کامپایل شده ایی که به شکا بایت کد است بر روی هر کامپیوتری با هر سیستم عاملی که JVM را داشته باشد اجرا خواهد شد. ماشین مجازی جاوا را مفسر جاوا یا روال جاوا (java routine) نیز می گویند. به طور کلی برنامه نویس جاوا نیاز به نوشتن چندین نسخه از برنامه خود برای محیط های مختلف را ندارد زیرا JVM آن را برای محیط های مختلف ترجمه می کند. برنامه&zwnj;های جاوا قبل از ترجمه به صورت یک فایل متنی ساده با پسوند .java ایجاد می شوند. این فایل به بایت کد تبدیل می شود. بایت کد سطحی را بین source code و کد ماشین اضافه می کند. به دلیل استفاده از ماشین مجازی که یک سطح بین سورس کد و کد ماشین ایجاد میکند اجرای برنامه جاوا کمی کند است. ولی امروز با استفاده از الگوریتم های بهینه شده و پیشرفت سخت افزاری این کند بودن نمی&zwnj;تواند در کیفیت برنامه شما تأثیری داشته باشد. زیرا این کندی فدای قابل حمل بودن جاوا و شعار سازندگان جاوا که یک بار بنویس همه جا استفاد کن شده است.</p>\n<p>با این حال اگر نیاز به برنامه ایی دارید که سرعتش از ماشین مجازی بیشتر باشد می&zwnj;توان دو روش عمل کرد</p>\n<p>- در برنامه جاوا از کد ماشین خاصی استفاده کنیم که منجر به برنامه ایی می&zwnj;شود که وابسته محیط است.<br />- از <strong>کامپایلر های بی درنگ</strong> (just in time) که بایت کد را به کدی برای ماشین خاص تبدیل می کند.</p>\n<h2>&nbsp;</h2>\n<h2><strong>جاوا در اینترنت و اپلت ها (applet)</strong></h2>\n<p>یکی از ویژگی&zwnj;های جاوا قابلیت اجرا شدن آن در وب جهانی است. مرورگر ها می&zwnj;توانند برنامه&zwnj;های جاوا را از اینترنت دریافت کنند و آن را در کامپیوتر کاربر اجرا کنند. برنامه جاوایی که در اینترنت اجرا می&zwnj;شود اپلت نام دارد. این برنامه&zwnj;ها همچون تصاویر در مرورگر ها ظاهر می&zwnj;شوند اما محاوره ایی هستند. یعنی قادر به دریافت و ورودی پاسخ دادن به آن&zwnj;ها هستند.</p>\n<h3><strong>برخی از کاربرد های اپلت</strong><br />- ایجاد انیمیشن <br />- بازی ها <br />-فرم هایی برای ارتباط با کاربران و سایر جلوه&zwnj;های محاوره ایی در صفحات وب.</h3>\n<p>ماشی مجازی جاوا می&zwnj;تواند در خود مرورگر وجود داشته باشد یا به صورت جداگانه load شود و در مرورگر قرار بگیرد و اپلت را اجرا کند.<br />از اصول نوشتن برنامه&zwnj;های کاربردی می&zwnj;توان برای applet ها استفاده کرد.<br />در بخش&zwnj;های بعدی بیشتر به مزایا و معایب اپلت ها می پردازیم.</p>\n<h2>&nbsp;</h2>\n<h2><strong>یادگیری جاوا آسان است</strong></h2>\n<p>جاوا زبان کوچکی است طراحی شده تا نوشتن برنامه&zwnj;های کاربردی کامپایل و اشکال زدایی آن&zwnj;ها آسان باشد. جاوا بعد از C++ که زبان شی گرایی است ایجاد شده و نحو (syntax) آن بسیار مشابه است و جنبه&zwnj;های منفی C++ را که مستعد خطا می&zwnj;شد را شامل نمی شود. مثلاً در جاوا اشاره گر به اشاره گر وجود ندارد . رشته و آرایه در جاوا برخلاف C++ به صورت اشیاء تعریف م ی شوند. مدیریت حافظه به صورت خودکار انجام می گیرد.<br />سبک های برنامه نویسی</p>\n<p><strong>روش ساخت یافته (structure approach)</strong> <br /><strong>روش شی گرا (object oriented approach)</strong><br /><strong>روش ساخت یافته</strong></p>\n<p>مسأله ایی که باید حل شود به چند مسأله ی کوچکتر به نام زیر مسأله تقسیم می گردد. هر زیر مسأله تحلیل می&zwnj;شود و جوابی برای آن به دست می آید. گاهی یک زیر مسأله به زیر مسأله های کوچکتری تبدیل می&zwnj;شود و جواب تمام زیر مسأله ها با هم ترکیب می&zwnj;شوند تا کل مسأله حل شود. به این فرآیند پیاده&zwnj;سازی برای یک روش ساخت یافته برنامه نویسی ساخت یافته می گویند. این روش به نام های طراحی بالا به پایین (top-down design) پایین به بالا (bottom-down design) پالایش گام به گام (stepwise refinement) و طراحی پیمانه ایی (modular design) نیز خوانده می شود.</p>\n<h2>&nbsp;</h2>\n<h2><strong>روش شی گرا</strong></h2>\n<p>یک روش برنامه نویسی پر استفاده است. اولین قدم در آن مشخص کردن اجزایی به نام اشیاء (object) می&zwnj;باشد که مبنای جواب مسأله است و تعییت چگونگی تعامل این اشیاء با یکدیگر را مشخص می کند.<br />هر شی داده ایی دارد.<br />هر شی عملیاتی بر روی داده هایش انجام می دهد.<br />شی داده&zwnj;ها و عملیات روی داده&zwnj;ها را در یک واحد (unit) ترکیب می کند. این فرآیند نیز بسته بندی (encapsulation) نام دارد.<br />در برنامه نویسی شی گرا برنامه نهایی مجموعه ایی از اشیاء هستند که با یکدیگر تعامل دارند.<br />زبان برنامه نویسی شی گرا</p>\n<p>زبان برنامه نویسی که (object oriented design) را پیاده&zwnj;سازی می&zwnj;کند زبان برنامه نویسی شی گرا Object Oriented Programming Language یا به اختصار OOP نامیده می شود.</p>\n<h2>&nbsp;</h2>\n<h2><strong>متد ها در جاوا method</strong></h2>\n<p>شی های موجود در برنامه&zwnj;های پیچیده معمولاً عملیات های فراوانی دارند. برای جدا کردن عملیات ها از یکدیگر و استفاده ی مؤثر آن&zwnj;ها از متد ها (method) برای پیاده&zwnj;سازی الگوریتم های موجود یک شی استفاده می کنیم.</p>\n<h2>&nbsp;</h2>\n<h2><strong>کلاس&zwnj;ها در جاوا class</strong></h2>\n<p>جاوا به شما اجازه می&zwnj;دهد که داده&zwnj;ها و عملیات های روی آن&zwnj;ها را در یک واحد ترکیب کنید که این واحد ها کلاس نام دارند. بنابراین در جاوا تمام برنامه&zwnj;ها از کلاس استفاده می کنند. نحوه تعریف کلاس و متد ها را در بخش&zwnj;های بعدی بررسی خواهیم کرد. <br />بسته به شرایط انتخاب نوع برنامه نویسی که ساخت یافته باشد یا شی گرا به شما بستگی داد. جاوا طراحی شده تا OOD را پیاده&zwnj;سازی کند. به عبارت دیگر جاوا یک زبان برنامه نویسی شی گرا است. OOD در رابطه با طراحی ساخت یافته نیز به خوبی کار می کند. یعنی یک طرح ساخت یافته به خوبی با OOD قابل پیاده&zwnj;سازی است. <br />چون هر شی شامل داده و عملیاتی روی آن&zwnj;ها است قبل از طراحی و استفاده از شی لازم است چگونگی نمایش داده&zwnj;ها در کامپیوتر را بدانیم. در بخش بعدی که می&zwnj;توان اولین بخش شروع آموزش جاوا آن را دانست با انواع نوع داده&zwnj;ها در جاوا آشنا می شویم.</p>\n<h3>&nbsp;</h3>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<h3>&nbsp;</h3>\n<h3><strong>&nbsp;منبع : it3du</strong></h3>', '2016-10-18 18:40:39', 22546897, 'programming.png', 34, 1578, 1, '2017-02-19 12:03:53'),
(121, 'انواع داده‌ها در جاوا Data type', 'انواع داده ها در جاوا و نحوه تعریف داده در جاوا', 'article,article keywords,article keywords2,keywords2', '<p>&nbsp;</p>\n<h1>انواع داده ها در جاوا و نحوه اعلان آنها</h1>\n<p>&nbsp;</p>\n<p>هدف برنامه نویسی جاوا دستکاری داده&zwnj;ها است. هر برنامه ایی انواع داده&zwnj;های مختلفی را دستکاری می کند. مثلاً یک برنامه فقط دستکاری اطلاعات عددی را انجام می&zwnj;دهد و برنامه ی دیگر فقط دستکاری اطلاعات رشته ایی (متنی) را انجام می دهد. حال ممکن است برنامه ایی هر دو این دستکاری ها را بتواند انجام دهد. ولی برای اینکه قادر به انجام محاسبات یا دستکاری ها باشد باید نوع داده ایی که می&zwnj;خواهد دستکاری را روی آن&zwnj;ها انجام دهد را بداند.</p>\n<p>به همین دلیل جاوا داده&zwnj;ها را به انواع مختلفی دسته بندی کرده است و هر عملیات خاص می&zwnj;تواند روی داده ی خاصی انجام گیرد.</p>\n<p>بنابر این نوع داده مجموعه ایی از مقادیر همراه با مجموعه ایی از عملیات رو ی آن&zwnj;ها است.</p>\n<p>&nbsp;</p>\n<h2>انواع داده&zwnj;های اولیه primitive data type</h2>\n<p>آن&zwnj;هایی که در زبان وجود دارند و زبان آن&zwnj;ها را می شناسد. اساسی&zwnj;ترین نوع داده&zwnj;ها در جاوا هستند و به سه دسته تقسیم می شوند.</p>\n<p><strong>صحیح integer</strong> : نوع داده ایی با مقدار صحیح و بدون اعشار و کاراکتر</p>\n<p><strong>ممیز شناور floating point</strong> : نوع داده ایی از نوع عدد اعشاری</p>\n<p><strong>بولی boolean</strong> : نوع داده ایی منطقی که دارای دو مقدار true و false است.</p>\n<p><strong>داده&zwnj;های صحیح به ۵ طبقه تقسیم می&zwnj;شوند</strong></p>\n<p dir="ltr">&nbsp;</p>\n<pre class="language-java"><code>char\nbyte\nshort\nint\nlong</code></pre>\n<p>&nbsp;</p>\n<p>مقادیر قابل نمایش انواع داده ایی مختلف در جدول&nbsp;زیر آمده است</p>\n<p>&nbsp;</p>\n<table>\n<tbody>\n<tr>\n<td>ذخیره سازی به بایت</td>\n<td>مقادیر</td>\n<td>\n<p>نوع داده</p>\n</td>\n</tr>\n<tr>\n<td>2</td>\n<td>0 to 65535 (2<sup>16</sup>-1)</td>\n<td>char</td>\n</tr>\n<tr>\n<td>1</td>\n<td>-128 (-2<sup>7</sup>) to -127 (2<sup>7</sup>-1)</td>\n<td>byte</td>\n</tr>\n<tr>\n<td>2</td>\n<td>-32768 (-2<sup>15</sup>) to 32767 (2<sup>15</sup>-1)</td>\n<td>short</td>\n</tr>\n<tr>\n<td>4</td>\n<td>-2147483648 (-2<sup>31</sup>) to 2147483647 (2<sup>31</sup>-1)</td>\n<td>int</td>\n</tr>\n<tr>\n<td>8</td>\n<td>-922337203684547758808(-2<sup>63</sup>) to 922337203684547758807 (2<sup>63</sup>-1)</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<p>اینکه از کدام نوع داده ایی استفاده کنیم به بزرگی عددی که نیاز دارید بستگی دارد. اوایل کامپیوتر و حافظه ی اصلی نسبتاً گران بودند و فقط حجم کمی از حافظه برای اجرای برنامه و دستکاری داده&zwnj;ها فرآهم بود. در نتیجه برنامه نویسان می بایست از حافظه بهینه استفاده کنند.</p>\n<p>امروزه با پیشرفت کامپیوتر و حافظه نسبتاً ارزان هستند. چون نوشتن برنامه و اجرای آن فرایند پیچیده ایی است نگرانی درباره اندازه اندازه حافظه موضوع مهمی نیست. اما برای استفاده بهینه و کارآمد از حافظه بهتر است برنامه نویس مناسبترین نوع را انتخاب کند.</p>\n<p>مثلاً برای نوع داده ایی اگر short کفایت می&zwnj;کند از int استفاده نکند.</p>\n<p>&nbsp;</p>\n<h2><strong>داده&zwnj;های ممیز شناور نیز به دو نوع طبقه بندی می شود</strong></h2>\n<p><strong>double</strong> : برای نمایش هر عدد حقیق بین -1.7E+308 و 1.7E+308 به کار می رود. مقدار حافظه برای double هشت بایت است.</p>\n<p><strong>float</strong> : برای نمایش هر عدد حقیقی بین -3.4E+38 و 3.4E+38 به کار می برد. مقدار حافظه برای float چهار بایت است.</p>\n<p>یعنی حداکثر اعداد اعشاری در (float) 6 یا 7 است و در (double) معمولاً 15 است. حداکثر تعداد ارقام با&zwnj;ارزش دقت (precision) نام دارد. گاهی به مقادیر float ذدقت معمولی و به مقادیر double دقت مضاعف گفته می شود.</p>\n<h2>&nbsp;</h2>\n<h2>شناسه ها در جاوا identifiers</h2>\n<p>اسامی هستند که در جاوا مورد استفاده قرار می گیرند. مثل متغییر ها ثوابت متد ها و کلاس ها.</p>\n<p>بعضی از شناسه ها از قبل تعریف شده اند. و بعضی از آن&zwnj;ها توسط برنامه نویس تعریف می گردد.</p>\n<p>تمام شناسه ها در جاوا باید از قوانین خاصی پیروی کنند.</p>\n<p>شناسه ها در جاوا فقط شامل حروف ارقام و کارکتر زیر ( _ ) و علامت $ است و باید با خط زیر یا حرف یا $ شروع شود. هیچ نماد دیگری نمی&zwnj;تواند در شناسه ظاهر شود.</p>\n<p><strong>شناسه های نا معتبر</strong> : 1abc one+to</p>\n<p><strong>شناسه های معتبر</strong> : avg1 _abc $abc</p>\n<p>در جاوا در نامگذاری شناسه ها بین حروف بزرگ و کوچک تفاوت قائل می شود. می&zwnj;گوییم جاوا حساس به حروف یا <strong>case senstive</strong> است. یعنی برای جاوا متغییر با شناسه abc با متغییری با شناسه aBc متفاوت است.</p>\n<p>&nbsp;</p>\n<h2 style="text-align: center;">کلمات رزروی در جاوا</h2>\n<table style="margin-left: auto; margin-right: auto;">\n<tbody>\n<tr>\n<td>abstract</td>\n<td>else</td>\n<td>interface</td>\n<td>switch</td>\n</tr>\n<tr>\n<td>assert</td>\n<td>enum</td>\n<td>long</td>\n<td>&nbsp;synchronized</td>\n</tr>\n<tr>\n<td>&nbsp;boolean</td>\n<td>&nbsp;extends</td>\n<td>&nbsp;native</td>\n<td>&nbsp;this</td>\n</tr>\n<tr>\n<td>break</td>\n<td>false</td>\n<td>&nbsp;new</td>\n<td>&nbsp;throw</td>\n</tr>\n<tr>\n<td>&nbsp;byte</td>\n<td>&nbsp;final</td>\n<td>&nbsp;null</td>\n<td>&nbsp;throws</td>\n</tr>\n<tr>\n<td>&nbsp;case</td>\n<td>&nbsp;finally</td>\n<td>&nbsp;package</td>\n<td>&nbsp;transient</td>\n</tr>\n<tr>\n<td>&nbsp;catch</td>\n<td>&nbsp;float</td>\n<td>&nbsp;private</td>\n<td>&nbsp;true</td>\n</tr>\n<tr>\n<td>&nbsp;class</td>\n<td>&nbsp;goto</td>\n<td>&nbsp;public</td>\n<td>&nbsp;void</td>\n</tr>\n<tr>\n<td>&nbsp;const</td>\n<td>&nbsp;return</td>\n<td>&nbsp;if</td>\n<td>&nbsp;volatile</td>\n</tr>\n<tr>\n<td>continue</td>\n<td>implements</td>\n<td>short</td>\n<td>while</td>\n</tr>\n<tr>\n<td>do</td>\n<td>instance of</td>\n<td>strictfp</td>\n<td>&nbsp;</td>\n</tr>\n<tr>\n<td>double</td>\n<td>int</td>\n<td>super</td>\n<td>&nbsp;</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<p><strong>منبع: it3du</strong></p>\n<p>&nbsp;</p>', '2016-10-18 20:20:38', 22546897, 'Data-Types-In-Java.jpg', 34, 1347, 1, '2017-02-19 12:05:28'),
(129, 'اولین برنامه JavaFX در netbeans', 'با استفاده از این مقاله می توانید تجربه اولین برنامه نویسی خودتون با JavaFX رو به دست بیاورید. این برنامه با IDE netbeans آموزش داده می شود.', 'article,article keywords,article keywords2,keywords2', '<h1>&nbsp;آموزش برنامه نویسی javaFX</h1>\n<p>&nbsp;</p>\n<h2>اولین برنامه JavaFX در netbeans</h2>\n<p>اولین برنامه JavaFX در محیط برنامه نویسی netbeans رو ایجاد می کنیم و توضیحات برنامه رو ارائه میدیم.</p>\n<p>از منوی File گزینه New Project رو انتخاب کنین.</p>\n<p>&nbsp;</p>\n<p><img style="display: block; margin-left: auto; margin-right: auto;" src="http://it3du.ir/upload/blog/image/01-fx.png" alt="اولین برنامه JavaFX در جاوا" width="553" height="378" /></p>\n<p>&nbsp;</p>\n<p>در پنجره باز شده از کادر category گزینه JavaFX رو و از کادر Projects گزینه JavaFX Application رو انتخاب کنید و دکمه next را انتخاب کنید.</p>\n<p>در مرحله بعدی باید تنظیمات و نام پروژه رو انتخاب کنین . دکمه Finish رو انتخاب کنین.</p>\n<p>&nbsp;</p>\n<p><img style="display: block; margin-left: auto; margin-right: auto;" src="../../upload/blog/image/02-fx.png" alt="آموزش برنامه نویسی JavaFX" width="454" height="300" /></p>\n<p>&nbsp;</p>\n<p>اگه محیط نت بینز شما از ساختن پروزه JavaFX پشتیبانی نمیکند می تونین از پروژه جاوا معمولی استفاده کنین. تنها تفاوت بین ایجاد کردن این دو پروژه این هستش که به صورت پیش فرض یک کلاس اجرایی با یک فریم JavaFX به صورت زیر ایجاد می کنه.</p>\n<p>کتابخانه های JavaFX در کتابخانه های استاندارد جاوا موجود هستند. بنابراین با ایجاد پروژه جاوا می تونین برنامه های کاربردی JavaFX رو ایجاد کنین.</p>\n<p>&nbsp;</p>\n<p><img style="display: block; margin-left: auto; margin-right: auto;" src="../../upload/blog/image/03-fx.png" alt="ایجاد برنامه javaFX" width="319" height="300" /></p>\n<p>&nbsp;</p>\n<p>کلاس اصلی برنامه که متد main در اون قرار داره باید از کلاس Application ارث بری کنه.کلاس Application در پکیج زیر قرار داره&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>javafx.application.Application</code></pre>\n<p>&nbsp;</p>\n<p>این کلاس متدی به نام Start داره و یک پارامتر از نوع کلاس Stage می گیره و Stage در پکیج زیر قرار داره :</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>javafx.stage.Stage</code></pre>\n<p>&nbsp;</p>\n<p>اینجا Stage کار JFrame رو در JavaFX میکنه.</p>\n<p>خط 19 در تصویر از کلاس Button یک دکمه ایجاد می کنه که این کلاس معادل کلاس Button و JButton پکیج awt و swing و در پکیج زیر قرار داره :</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>javafx.scene.control.Button;</code></pre>\n<p>&nbsp;</p>\n<p>این پکیج کلاس های دیگری رو هم داره مثل &nbsp;TextField , TextArea, RadioButton, CheckBox, Menu, MenuBar, MenuItem, Label, ToolBar که معادل کلاس های موجود در پکیج awt و swing هستش.</p>\n<p>خط 21 برای دکمه ایجاد شده یک رویداد ایجاد می کند. با استفاده از متد setOnAction که پارامتر آن واسطی از EventHandler میگیره و متد handle رو پیاده سازی می کند و رویداد های مربوط به دکمه در این متد تعریف می شود.</p>\n<p>پکیج های مربوط به این کلاس ها که به برنامه اضافه شده در برنامه موجود هستش.</p>\n<p>خط 27 برنامه از کلاس StackPane شی به نام root ایجاد می کند که یک layout بندی صفحه هستش و عناصری رو می تونه به خودش اضافه کنه.</p>\n<p>در پکیج زیر قرار داره&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>javafx.scene.layout.StackPane</code></pre>\n<p>&nbsp;</p>\n<p>و برای اضافه کردن عنصری به آن از دستور زیر استفاده می شود :</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code> root.getChildren().add(btn);</code></pre>\n<p>&nbsp;</p>\n<p>حالا شما از کلاس Scene معادل کلاس Panel و JPanel توی جاوا اف ایکس استفاده می کنین و به Stage اضافه می کنین.</p>\n<p>کلاس Scene سازنده های مختلفی داره و در تصویر زیر مشخص شده</p>\n<p>&nbsp;</p>\n<p><img style="display: block; margin-left: auto; margin-right: auto;" src="../../upload/blog/image/scene-contructor.png" alt="کلاس scene در JavaFX" width="534" height="218" /></p>\n<p>&nbsp;</p>\n<p>Parent یک شی هستش که می تونه دکمه ، لیبل و هر چیز دیگه ایی باشه که در این جا ما root رو به اون مقدار میدیم که یک طرح بندی صفحه هست که داخل خودش یک دکمه رو جای داده.</p>\n<p>دو مقدار double طول و عرض Scene را مشخص می کند و Paint رنگ پس زمینه Scene را مشخص می کند.</p>\n<p dir="rtl">شی stage متد هایی دارد که از متد setTitle برای تعیین عنوان frame و setScene برای ست کردن یک scene در stage استفاده می شه و در خط 32 با استفاده از متد show که معادل متد setVisible در جاوا هستش که اجازه نمایش فریم را صادر می کند.</p>\n<p dir="rtl">حالا اگه کد زیر رو هم به ادامه متد start اضافه کنین یک فریم دیگه ایجاد می شه که در خودش یک دکمه داره.</p>\n<p dir="rtl">&nbsp;</p>\n<pre class="language-java"><code>Stage s = new Stage();\nScene sc = new Scene(new Button("Test"), 500,500);\ns.setScene(sc);\ns.show();</code></pre>\n<p dir="rtl">&nbsp;</p>\n<p dir="rtl">این اولین برنامه JavaFX شما می تونه باشه و اگه با JavaSE آشنایی داشته باشین فقط می مونه یادگیری کتابخانه های JavaFx که کار زیاد سختی نمی تونه باشه.</p>\n<p dir="rtl">نکته مهم دیگه توی JavaFX استفاده از CSS برای کنترل چیدمان عناصر روی صفحه و تنظیم خواص عناصر می باشد که ویژگی جالبی می تونه به حساب بیاد.</p>\n<p dir="rtl">آموزش های بیشتری در رابطه با JavaFX قرار خواهیم داد.</p>\n<p dir="rtl">&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p dir="rtl">&nbsp;</p>\n<h3>منبع: it3du.ir</h3>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>', '2016-10-22 19:51:11', 22546897, 'javafx-thumbnail-blog.png', 35, 993, 1, '2018-02-27 15:13:41'),
(130, 'JavaFX چیست', 'در این مقاله راجع به سکویی از جاوا به نام JavaFX صحبت خواهیم کرد. سکویی که برای رقابت با محصولات سامانه های رو میزی همچون ادوب فلش پلیر ، سیلور لایت و ... رقابت خواهد کرد', 'article,article keywords,article keywords2,keywords2', '<p>&nbsp;</p>\n<h1>جاوا اف ایکس چیست و کاربرد آن در چه زمینه هایی است</h1>\n<p>&nbsp;</p>\n<p>جاوااف&zwnj;اکس (به انگلیسی: JavaFX) سکوی جاوایی است که برای خلق و تحویل کاربردهای غنی اینترنتی که بتواند در پهنهٔ وسیعی از دستگاه&zwnj;های متصل به اینترنت اجرا گردد.</p>\n<p>تگارش کنونی آن توسعه دهندگان را قادر به ساخت برنامه برای محیطهایرایانه رایانه رومیزی، دستگاه&zwnj;های بازی ویدیویی، پخش کننده&zwnj;های بلوری، و سایر سکوها را شامل می&zwnj;شود.</p>\n<p>جاوااف ایکس، بر مبنای فناوری جاوا ایجاد گردیده است. در نگارش رایانه رومیزی، هم اکنون از سیستم عامل&zwnj;های ویندوز اکس&zwnj;پی، ویندوز ویستا، مکینتاش، پشتیبانی می&zwnj;نماید. در نگارش جاوا اف ایکس ۱٫۲، سان نسخه&zwnj;های اولیه&zwnj;ای را برای لینوکس و اپن سولاریس ارایه نمود. در نگارش موبایل، جاوا اف ایکس، قابلیت اجرایی در سیستم عامل&zwnj;هایی چون، سیمبیان، ویندوز موبایل، و سیستم عامل&zwnj;های بی درنگ را داراست.</p>\n<p>نگارش کنونی این سکو، شامل اجزا زیر است:</p>\n<p>کیت توسعه نرم&zwnj;افزار جاوا اف ایکس: که شامل کامپایلر، ابزار زمان اجرایی، گرافیکی، خدمات رسانه&zwnj;ای وب و کتابخانه غنی متنی است.</p>\n<p>محیط توسعه نتبینز برای جاوا اف ایکس: نتبینز امکام اضافه کردن با استفاده از صفحه&zwnj;ای برای کشیدن و رها کردن برای اضافه نمودن اشیایی با قابلیت حرکت، پویانمایی و همچنین مجموعه از نمونه&zwnj;ها و مثالها برای یادگیری.</p>\n<p>برای اکلیپس، افزونه&zwnj;ای تحت حمایت پروژه کنایی وجود دارد. ابزارها و افرونه&zwnj;هایی برای کارهای خلاق: افزونه&zwnj;هایی برای تبدیل گرافیک موجود در ادوب فوتوشاپ و ادوب ایلسفقیتور به کدهای جاوا اف ایکس را داراست.</p>\n<p>ابزارهایی برای تبدیل اس وی جی به کدهای جاوا اف ایکس. صاحب نظران بر این باورند که این محصول در بازار سامانه&zwnj;های رایانه رومیزی، با محصولاتی چوت ادوب فلش پلیر، ادوبی ایر، اپن لاسزلو و سیلورلایت مایکروسافت، در رقابت خواهد بود.</p>\n<p>منبع این مقاله : ویکی پدیا برای دسترسی به مقاله کامل در ویکی پدیا <a title="JavaFX چیست" href="https://fa.wikipedia.org/wiki/%D8%AC%D8%A7%D9%88%D8%A7_%D8%A7%D9%81%E2%80%8C%D8%A7%DA%A9%D8%B3" target="_blank">اینجا </a>کلیک کنید.</p>\n<p>در مقاله بعدی ایجاد یک برنامه با JavaFX رو توی <a title="netbeans" href="https://fa.wikipedia.org/wiki/%D9%86%D8%AA%E2%80%8C%D8%A8%DB%8C%D9%86%D8%B2" target="_blank">محیط نت بینز</a> ایجاد می کنیم.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع: ویکی پدیا</h3>', '2016-10-22 19:56:12', 22546897, 'javafx-thumbnail-blog.png', 35, 812, 1, '2017-02-19 12:16:53'),
(132, 'بدست آوردن اندازه صفحه نمایش با استفاده از جاوا', 'چگونه در جاوا طول و عرض صفحه نمایش را بدست بیاوریم. در این مقاله شما با استفاده از کتابخانه استاندارد جاوا طول و عرض صفحه نمایش رو به دست می آورید', 'article,article keywords,article keywords2,keywords2', '<h1>&nbsp;چگونه اندازه صفحه نمایش را در جاوا به دست آورم</h1>\n<p>&nbsp;</p>\n<p>با استفاده از کلاس Toolkit می توان این کار را انجام داد که هم می تونین از متد های getWidth و getHeigth به صورت زیر استفاده کنین :</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>int width = (int) Toolkit.getDefaultToolkit().getScreenSize().getWidth();\nint height= (int) Toolkit.getDefaultToolkit().getScreenSize().getHeigth();</code></pre>\n<p>&nbsp;</p>\n<p>می تونین از یک Dimension هم استفاده کنین که یک ابعاد رو می گیره و متد های getWidth و getHeight برای برگردوندن مقدار ارتفاع و پهنا داره و برای تعیین اندازه یک فریم هم میشه ازش استفاده کرد</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>Dimension d = Toolkit.getDefaultToolkit().getScreenSize();</code></pre>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع: it3du.ir</h3>', '2016-10-22 20:27:03', 22546897, 'java-thumbnail-blog.jpg', 34, 676, 1, '2017-02-19 12:16:24'),
(135, 'نمونه سازی کلاس و ایجاد متغییر مرجع', 'با تعریف کلاس در جاوا، اشیای واقعی را ایجاد نمی کنید. کلاس یک توضیع انتزاعی از یک شی است. بنابراین برای استفاده از یک کلاس شما باید از آن کلاس نمونه سازی کنید. در این مطلب به نمونه سازی می پردازیم', 'article,article keywords,article keywords2,keywords2', '<p>&nbsp;</p>\n<h1>چگونه از یک کلاس در جاوا نمونه ایجاد کنم</h1>\n<p>&nbsp;</p>\n<p>زمانی که شما کلاسی در جاوا تعریف می کنید، در واقع شی ایی را تعریف کرده اید. زبان های برنامه نویسی که از شی گرایی پشتیبانی می کنند تمام اشیای دنیای واقعی را به صورت کلاس مدل سازی می کنند. برای مثال یک برنامه مدیریت دانش آموز را در نظر بگیرید.</p>\n<p>در این برنامه شما اطلاعات دانش آموز های کلاس خودتان را می خواهید ذخیره کنید. در واقع شما به عنوان برنامه نویس دانش آموز را یک شی از دنیای واقعی می بینید و برای پیاده سازی آن در نرم افزار، آن را به صورت یک کلاس طراحی خواهید کرد.</p>\n<p>نحوه اعلان یک کلاس و اینکه یک کلاس می تواند چه متد ها و متغییر هایی را شامل باشد و نوع دستیابی آن را در قسمت قبل مرور کردیم.</p>\n<p><strong>حالا پس از آن که شما کلاسی برای دانش آموز طراحی کردید چگونه می توانید از آن در برنامه خود استفاده کنید؟</strong></p>\n<p>شما در آموزش های قبل آموختید که دو نوع&nbsp;متغییر در جاوا امکان پذیر است.&nbsp;<strong>نوع داده اولیه&nbsp;</strong>یا&nbsp;<strong>Primitive Data Type&nbsp;</strong>و <strong>متغییر های مرجع</strong> یا <strong>Reference variables.</strong></p>\n<p><strong>یاد آوری :&nbsp;</strong>متغییر های نوع داده اولیه، متغییر هایی بودند که زبان برنامه نویسی آن را می شناسد. مانند int، double و... و متغییر های مرجع در واقع متغییر هایی بودند که از یک کلاس تعریف می شوند.</p>\n<p>بنابراین به متغییر های نوع داده اولیه ،&nbsp;<strong>متغییر های نوع داده اولیه</strong> و به متغییر هایی که از یک کلاس تعریف می شوند،&nbsp;<strong>متغییر های مرجع&nbsp;</strong>گفته می شود.</p>\n<p>برای استفاده از یک کلاس که آن را تعریف کرده ایم باید یک متغییر مرجع ایجاد کنیم.</p>\n<p>اعلان کلاس در جاوا، اشیای واقعی را ایجاد نمی کند. همانطور که نقشه یک ساختمان، ساختمان واقعی را به وجود نمی آورد. کلاس توصیف انتزاعی از یک شی است. قدم بعدی برای مدل سازی اشیای دنیای واقعی،&nbsp;<strong>نمونه سازی&nbsp;</strong>یا&nbsp;<strong>instantiation</strong> از یک کلاس است تا شی ایی از آن کلاس به وجود آورد. نمونه سازی از یک کلاس را&nbsp;<strong>اعلان شی&nbsp;</strong>نیز می گویند.</p>\n<p>در مثال ما که دانش آموز را به عنوان یک شی از دنیای واقعی به صورت کلاس ایجاد کردیم برای استفاده از آن باید <strong>نمونه سازی</strong> کنیم.</p>\n<h2>نمونه سازی از کلاس ها در جاوا چگونه است ؟</h2>\n<p>کلاسی با نام Student به صورت زیر تعریف کرده ایم</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Student {\n    \n    private String name = "Student name";\n    private int age = 24;\n    private String field = "Information Technology";\n\n    public String getName() {\n        return name;\n    }\n\n    public String getField() {\n        return field;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setName(String n) {\n        name = n;\n    }\n\n    public void setField(String f) {\n        field = f;\n    }\n\n    public void setAge(int a) {\n        age = a;\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>کلاسی به نام Student ایجاد کردیم و سه متغییر نوع داده اولیه از نوع رشته و عدد صحیح با نوع دسترسی private تعریف کردیم. متغییر ها را مقدار دهی اولیه نیز کرده ایم.</p>\n<p>متد های <strong>getter</strong> و <strong>setter</strong> برای متغییر ها تعریف کردیم.</p>\n<p>درواقع متد های getter و setter در کلاس ها برای دستکاری متغییر های درون کلاسی و برگرداندن مقدار متغییر ها استفاده می شود. متد getter برای متغییر&nbsp;age را نگاه کنید. نام متد با get آغاز می شود و نام متغییر به آن وصل داده می شود و نام متد getAge خواهد شد. این متد مقدار متغییر age که در کلاس Student به صورت private تعریف شده است را بر میگرداند. این ویژگی به سایر کلاس ها این امکان را می دهد که در صورت نمونه سازی از کلاس Student بتواند از طریق متد getAge به مقدار متغییر age در کلاس Student دسترسی داشته باشند.</p>\n<p><strong>نکته :&nbsp;</strong>نام انتخابی برای متد های getter و &nbsp;setter حتما نباید به این صورت باشد. شما می توانید نام های دلخواه برای متد ها انتخاب کنید. مثلا برای متد getter متغییر age به صورت زیر عمل کنید :</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public int studentAge() {\n    return age;\n}</code></pre>\n<p>&nbsp;</p>\n<p>اما با نام گذاری متد به صورت getAge کد نویسی شما به صورت استاندارد خواهد بود و در زمان کد نویسی راحت تر خواهید فهمید که این متد برای چیست!</p>\n<p>اما در رابطه با متد های setter نوع داده ایی که متد به عنوان پارامتر در ورودی می گیرد باید با نوع داده ایی که برای آن، متد setter&nbsp;می نویسیم یکسان باشد. برای متغییر age باید پارامتر ورودی به صورت int باشد که برای هر متد بسته به متغییرش نوع داده ایی مناسب را تعریف کرده ایم.</p>\n<p>&nbsp;</p>\n<p><strong>حالا به موضوع اصلی برمی گردیم. نحوه ایجاد نمونه یا آبجکت در جاوا به صورت زیر است</strong></p>\n<p>ابتدا کلاسی به نام دلخواهتان ایجاد کنید. ما کلاسی به نام MyProgram را در فایلی به نام MyProgram.java ایجاد می کنیم</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n}</code></pre>\n<p>&nbsp;</p>\n<p>چون این کلاس باید کلاس اجرایی برنامه ما باشد. بنابراین متد main باید در آن پیاده سازی شود</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n    public static void main(String[] args) {\n        // create object from Student class here\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>حالا با دستور زیر یک شی یا object از کلاس Student ایجاد خواهیم کرد</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n    public static void main(String[] args) {\n        Student obj;\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>حالا متغییر مرجعی از کلاس Student با نام obj ایجاد کرده ایم. اما این متغییر به جایی اشاره نمی کند و حافظه ایی برای آن تخصیص داده نشده.</p>\n<p>زمانی که شما متغییر صحیح با نام intVal تعریف می کنید به کامپایلر می گویید که حافظه ایی به آن تخصیص بدهد. در متغیر های مرجع شما برای تخصیص حافظه به متغییری که ایجاد کرده اید، باید از <strong>عملگر new</strong> استفاده کنید.</p>\n<p>بنابر این توجه داشته باشید در تعریف متغییر های مرجع باید از عملگر new برای تخصیص حافظه استفاده کنید. در غیر اینصورت اگر صرفا متغییری از کلاس بدون تخصیص حافظه مورد استفاده قرار گیرد با خطا در زمان کامپایل مواجه می شود.</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n    public static void main(String[] args) {\n        Student obj;\n        obj = new Student();\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>حالا با استفاده از دستور new فضایی از حافظه را به شی obj اختصاص دادیم. در واقع این کار را کامپایلر انجام می دهد!</p>\n<p>دقت کنید که در دستور new در کد بالا، ما نام کلاس Student + () &nbsp;را قرار دادیم. درواقع کلاس را با استفاده از <strong>کانستراکتور</strong> یا <strong>سازنده</strong> آن new کرده ایم. در بخش های آینده در رابطه با Constructor ها یا سازنده های کلاس در جاوا صحبت خواهیم کرد.</p>\n<h3>سوال: با استفاده از آبجکت obj که ایجاد کردم به کدام عناصر کلاس Student دسترسی دارم؟</h3>\n<p>شما فقط به متد های کلاس دسترسی دارید.</p>\n<p>با استفاده از نام آبجکت + نقطه + نام متد یا متغییر مورد نظر می توانید فراخوانی مورد نظرتان را انجام دهید.</p>\n<p>حالا بعد از نمونه سازی از کلاس می خواهیم متد getAge را به خروجی ببریم و مقدار آن را چاپ کنیم</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n    public static void main(String[] args) {\n        Student obj;\n        obj = new Student();\n        System.out.print("Student Age value From Student Class " + obj.getAge());\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>متد getAge مقداری را return می کند. مطمئنا خروجی برنامه به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Student Age value From Student Class 24</code></pre>\n<p>&nbsp;</p>\n<p>زیرا مقدار پیش فرض متغییر age در کلاس Student عدد 24 است.</p>\n<p>حالا میخواهیم مقادیر پیش فرض متغییر های کلاس را تغییر دهیم و آن ها را به خروجی ببریم. با استفاده از متد های setter این کار را انجام می دهیم</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class MyProgram {\n    \n    public static void main(String[] args) {\n        Student obj;\n        obj = new Student();\n        obj.setName("Reza");\n        obj.setAge(25);\n        obj.setField("Software");\n\n        System.out.print("Student Name: " + obj.getName() + " , ");\n        System.out.print("Age: " + obj.getAge() + " , ");\n        System.out.print("Field: " + obj.getField());\n\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>و خروجی زیر را خواهیم دید</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Student Name: Reza , Age: 25 , Field: SW</code></pre>\n<p>&nbsp;</p>\n<p><strong>برای کامپایل سورس کد ها به نکات زیر توجه کنید</strong></p>\n<p>به دلیل اینکه مباحث مربوط به پکیج بندی گفته نشده دو فایل Student.java و MyProgram.java باید در یک دایرکتوری قرار داشته باشند. به صورت زیر</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>../\n* java |\n       |-&gt; MyProgram.java\n       |-&gt; Student.java</code></pre>\n<p>&nbsp;</p>\n<p>فایل های سورس کد جاوا در پوشه ایی یکسان به نام java قرار دارد. در غیر اینصورت در زمان کامپایل با خطا مواجه خواهید شد.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع: it3du</h3>\n<p>&nbsp;</p>', '2016-10-29 16:02:46', 22546897, 'create-object-from-class-in-java.jpg', 34, 1835, 1, '2017-02-19 12:22:06');
INSERT INTO `articles` (`article_id`, `article_title`, `article_precontent`, `article_keywords`, `article_content`, `article_date`, `article_author`, `article_thumbnail`, `article_category`, `article_view`, `article_status`, `article_last_modified`) VALUES
(136, 'سازنده ها در جاوا', 'یکی از متد های مهم در کلاس ها، سازنده ها یا constructor ها می باشند. کلاس ها دارای سازنده های پیش فرض هستند...', 'article,article keywords,article keywords2,keywords2', '<h1>Constructor در جاوا چیست و چه کاربردی دارد</h1>\n<h2>سازنده ها&nbsp;</h2>\n<p>یکی از مهمترین متد ها در کلاس، متد سازنده یا constructor می باشد. متد سازنده برای مقدار اولیه دادن به صفات (متغییر) اختصاصی به کار می رود.</p>\n<p><strong>هر کلاسی که ایجاد می شود دارای یک سازنده پیش فرض یا Default Constructor می باشد.</strong></p>\n<p>وقتی با عملگر new شی ای از یک کلاس ایجاد می کنید، این عملگر اعمال زیر را انجام می دهد</p>\n<ul>\n<li>فیلد های عددی را برابر صفر قرار می دهد</li>\n<li>فیلد های کاراکتری را برابر با یونیکد \'\\u0000\' قرار می دهد</li>\n<li>فیلد های بولین را برابر با false قرار می هد</li>\n<li>فیلد های نوع شی را برابر با تهی (null) قرار می دهد</li>\n</ul>\n<p>برای درک بهتر این موضوع کد زیر را در یک فایل Test.java قرار دهید و آن را کامپایل کنید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Test {\n	public static void main(String[] args) {\n		Test2 obj = new Test2();\n		System.out.println("num : " + obj.num);\n		System.out.println("ch : " + obj.ch);\n		System.out.println("check : " + obj.check);\n		System.out.println("str : " + obj.str);\n		System.out.println("Test2 object : " + obj.test2obj);\n	}\n}\n\nclass Test2 {\n	int num;\n	char ch;\n	boolean check;\n	String str;\n	Test2 test2obj;\n}</code></pre>\n<p style="top: 215px;">&nbsp;</p>\n<p style="top: 215px;">توجه کنید که دو کلاس در فایل Test.java وجود دارد. یک کلاس public هم نام با نام فایل که متد main در آن قرار دارد و کلاس Test2 که دسترسی آن فقط در همین فایل می باشد.</p>\n<p style="top: 215px;">خروجی زمانی که فایل را کامپایل کنید به صورت زیر می باشد</p>\n<p style="top: 215px;">&nbsp;</p>\n<pre class="language-markup"><code>num : 0\nch :\ncheck : false\nstr : null\nTest2 object : null</code></pre>\n<p style="top: 215px;">&nbsp;</p>\n<p style="top: 215px;">شما هیچ مقدار اولیه ایی به متغییر های کلاس Test2 ندادید. اما زمانی که آبجکتی از کلاس Test2 را با عملگر&nbsp;<strong>new&nbsp;</strong>تخصیص حافظه برای آن در نظر گرفتید، اگر برای متغییر ها مقدار اولیه در نظر نگرفته باشید، به صورت پیش فرض برای آن ها مقادیری در نظر گرفته می شود.</p>\n<p style="top: 215px;">&nbsp;</p>\n<p style="top: 215px;">بنابر این اگر می خواهید فیلد های اشیایی که ایجاد می شوند، مقادیری غیر از مقدار پیش فرض را بپذیرند، باید سازنده هایی بنویسید که مقادیر دلخواه را به فیلد ها نسبت دهند.</p>\n<p style="top: 215px;"><strong>مشخصات سازنده ها عبارت است از</strong></p>\n<ul>\n<li style="top: 215px;">همنام با نام کلاسی است که در آن تعریف می شود</li>\n<li style="top: 215px;">فاقد نوع است. یعنی Data type ندارد حتی void هم نمی باشد</li>\n<li style="top: 215px;">هنگام ایجاد شی ای از کلاس، به طور خودکار ایجاد می گردد (توسط عملگر new)</li>\n<li style="top: 215px;">هیچ مقداری را بر نمی گرداند (return نمی کند)</li>\n<li style="top: 215px;">یک کلاس می تواند بیش از یک سازنده داشته باشد</li>\n</ul>\n<p>حالا مثال ساده ایی از یک کلاس با سازنده را در زیر می بینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Example_1 {\n	\n	public Example_1() {\n		System.out.println("Print From Example_1 Constructor");\n	}\n	\n	public static void main(String[] args) {\n		Example_1 obj = new Example_1();\n	}\n	\n}</code></pre>\n<p>&nbsp;</p>\n<p>زمانی که با استفاده از عملگر new شی ای از کلاس Example_1 را تخصیص حافظه می دهیم، بعد از عملگر new مشخص می کنیم از کدام کانستراکتور برای مقدار دهی اولیه متغییر های کلاس ها استفاده می کنیم.</p>\n<p>&nbsp;به صورت پیش فرض شما زمانی که برای یک کلاس کانستراکتوری تعریف نمی کنید. یک <strong>کانستراکتور پیش فرض&nbsp;</strong> یا&nbsp;<strong>Default Constructor&nbsp;</strong>برای آن کلاس به صورت خودکار ایجاد می شود.</p>\n<h2>چند سازنده در یک کلاس</h2>\n<p>همانطور که&nbsp;قبلا اشاره کردیم میتوانیم متد های همنام ولی با امضاهای متفاوت داشته باشیم. کد زیر را ببینید و برای درک مطلب آن را کامپایل کنید</p>\n<p dir="ltr">&nbsp;</p>\n<pre class="language-java"><code>public class MethodTest {\n	public void m1(String s) {\n		System.out.println("Print from m1(String s) : " + s);\n	}\n	\n	public void m1(int i) {\n		System.out.println("Print from m1(int i) : " + i);\n	}\n	\n	public static void main(String[] args) {\n		new MethodTest().m1(10);\n		new MethodTest().m1("string");\n	}\n	\n}</code></pre>\n<p>&nbsp;</p>\n<p>همانطور که در کد بالا مشاهده می کنید. دو متد m1 از نوع void وجود دارد. یک متد پارامتری از نوع int می گیرد و یک متد پارامتری از نوع String.</p>\n<p>بنابراین چون مقدار بازگشتی متدهای m1 با هم برابر است، می توانیم متد های هم نام اما با پارامتر های متفاوت در ورودی متد داشته باشیم. در متد main مشاهده میکنید که به صورت زیر فضای حافظه تخصیص داده شده است</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>new MethodTest().m1(10);\nnew MethodTest().m1("string");</code></pre>\n<p>&nbsp;</p>\n<p>ما نمونه ایی از کلاس MethodTest ایجاد کردیم اما آن را در متغییری از نوع آن کلاس قرار ندادیم. این کار به صورت زیر نیز قابل پیاده سازی بود</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>MethodTest obj = new MethodTest();\nobj.m1(10);\nobj.m1("string");</code></pre>\n<p>&nbsp;</p>\n<p>با دانستن این موضوع می توانیم دریابیم که یک کلاس می تواند چند سازنده داشته باشد اما با نوع پارامتر ورودی مختلف و یا تعداد مختلف پارامتر در ورودی.</p>\n<p>به سورس زیر نگاه کنید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Example_2 {\n	\n	int integerNumber;\n	float floatNumber;\n	\n	public Example_2(int i) {\n		integerNumber = i;\n		System.out.println("print from constructor by integer parameter : " + integerNumber);\n	}\n	public Example_2(float f) {\n		floatNumber = f;\n		System.out.println("print from constructor by float parameter : " + floatNumber);\n	}\n	\n	public static void main(String[] args) {\n		new Example_2(10);\n		new Example_2(10.3f);\n	}\n	\n}</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;همانطور که در سورس بالا مشاهده می کنید دو سازنده داریم. سازنده اول پارامتری از نوع عدد صحیح می گیرد و سازنده دوم عددی اعشاری را به عنوان پارامتر دریافت می کند. برای درک بهتر می توانید سورس را کامپابل و خروجی زیر را مشاهده کنید</p>\n<p>&nbsp;</p>\n<pre class="language-markup" dir="ltr"><code>print from constructor by integer parameter : 10\nprint from constructor by float parameter : 10.3</code></pre>\n<p>&nbsp;</p>\n<p><strong>نکته مهم : زمانی که برای کلاسی سازنده ی پیش فرض ایجاد نمی کنید و سازنده به غیر از سازنده پیش فرض در آن قرار می دهید دیگر به صورت خودکار سازنده پیش فرض برای کلاس توسط کامپایلر در نظر گرفته نمی شود. بنابر این اگر سازنده پیش فرض را نیاز دارید، در صورت تعریف سازنده های دیگر در آن کلاس، شما نیاز دارید سازنده پیش فرض را نیز خودتان ایجاد کنید. در غیر اینصورت در زمان کامپایل اگر در جایی از برنامه ان کلاس با سازنده پیش فرض مقدار دهی اولیه شود با خطا مواجه خواهید شد.</strong>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>فراخوانی سازنده توسط سازنده ایی دیگر</h2>\n<p>شما می توانید در بدنه یک سازنده دستوری برای فرآخوانی یک سازنده دیگر بنویسید. برای مثال کلاسی سازنده ایی با ورودی int دارد. برای آن یک سازنده پیش فرض نیز در نظر گرفته اید. اگر کلاس با سازنده int مقدار دهی اولیه نشد و با سازنده پیش فرض مقدار دهی را انجام دادیم، آنگاه در سازنده پیش فرض دستور فراخوانی سازنده با پارامتر int با یک مقدار پیش فرض را قرار می دهیم.</p>\n<p>به مثال زیر توجه کنید&nbsp;<strong>(مثال زیر اشتباه است و در زمان کامپایل با خطا مواجه می شود)</strong></p>\n<p>&nbsp;</p>\n<p dir="ltr">&nbsp;</p>\n<pre class="language-java"><code>public class Example_3 {\n	public Example_3() {\n		Example_3(10);\n	}\n	\n	public Example_3(int i) {\n		System.out.println(i);\n	}\n	\n	public static void main(String[] args) {\n		new Example_3();\n	}\n}</code></pre>\n<p>&nbsp;</p>\n<p>مشکل سورس کد بالا این است که برای فراخوانی کانستراکتوری در داخل کلاس نمی توان از نام آن به تنهایی استفاده کرد. کد زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public Example_3() {\n    Example_3(10);\n}\n\npublic Example_3(int i) {\n    System.out.println(i);\n}</code></pre>\n<p>&nbsp;</p>\n<p>در سازنده پیش فرض، سازنده ایی با پارامتر int را فراخوانی کردیم، که این کار خطا در زمان کامپایل را به همراه دارد.&nbsp;<strong>راه حل&nbsp;این کار استفاده از مرجع this می باشد.</strong></p>\n<p><strong>this&nbsp;</strong>را در جلسه بعد به صورت مفصل بررسی خواهیم کرد. ولی در حال حاضر در همین حد برای استفاده از فراخوانی سازنده توسط سازنده ایی دیگر توضیح خواهیم داد. در واقع زمانی که بخواهید سازنده ایی در کلاس جاری را فراخوانی کنید از&nbsp;<strong>مرجع this&nbsp;</strong>استفاده می کنید. کد زیر را ببنید.</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Example_4 {\n	public Example_4() {\n		this(10);\n		//this("abcd");\n		//this(10,"abcd");\n	}\n	\n	public Example_4(int i) {\n		System.out.println("Print from constructor by Integer parameter");\n	}\n	\n	public Example_4(String s) {\n		System.out.println("Print from constructor by String parameter");\n	}\n	\n	public Example_4(int i, String s) {\n		System.out.println("Print from constructor by two parameters");\n	}\n	\n	public static void main(String[] args) {\n		new Example_4();\n	}\n}</code></pre>\n<p>&nbsp;</p>\n<p>خروجی برنامه به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Print from constructor by Integer parameter</code></pre>\n<p>&nbsp;</p>\n<h3>نکته بسیار مهم در فراخوانی سازنده ها با استفاده از مرجع this</h3>\n<p>دستور this باید اولین&nbsp;خط دستور در هر جایی که در حال&nbsp;فراخوانی است باشد. در سازنده پیش فرض Example_4 سه دستور this وجود دارد که دو خط از دستورات کامنت می باشد. اگر شما دو دستور this در آن جا داشته باشید با خطای زمان کامپایل مواجه می شوید. متن خطا به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>error: call to this must be first statement in constructor</code></pre>\n<p>&nbsp;</p>\n<p>چون شما دو دستور this در بدنه سازنده پیش فرض استفاده کرده اید، کامپایلر this اول را صحیح در نظر می گیرد و برای this دوم اخطار بالا را می دهد.</p>\n<p>کد زیر هم خطا می باشد، چون دستور this در سطر اول به کار نرفته است.&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public Example_4() {\n    System.out.println("Print from default constructor");\n    this(10);\n}</code></pre>\n<p>&nbsp;</p>\n<p>چون سازنده برای جلوگیری از خطای ناشی از عدم مقدار دهی اولیه پارامتر های یک کلاس است، و اگر شما می خواهید فراخوانی سازنده ایی را انجام بدهید، باید اولین دستور شما باشد. وگرنه اگر در دستور های غیر از دستور اول، شما برای فراخوانی سازنده باشد باز امکان بروز خطای ناشی از&nbsp;مقدار اولیه نشدن پارامتر های کلاس وجود دارد و جاوا این اجازه را به شما نمی دهد.</p>\n<p>&nbsp;</p>\n<p><strong>این یکی از کاربرد های this بود. در جلسه بعد کاربرد های دیگر را نیز توضیح خواهیم داد.</strong></p>\n<p>&nbsp;</p>\n<h2>بحث تکمیلی</h2>\n<p>حالا برای تکمیل بحث سازنده ها یک برنامه می نوسیم که دارای دو کلاس با نام های Student و &nbsp;Example_3 می باشد.</p>\n<p>کلاس Student سه فیلد name ، age و field دارد. با استفاده از کانستراکتور با سه پارامتر در ورودی این مقادیر را در زمان ایجاد آبجکت، مقدار دهی اولیه میکنیم.</p>\n<p><strong>در واقع کانستراکتور این اطمینان را می دهد که متغییر های کلاس حتما مقدار دهی اولیه شوند و از بروز خطاهای احتمالی جلوگیری شود.</strong></p>\n<p>کد های زیر را در فایل Student.java قرار دهید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Student {\n	private int age;\n	private String name;\n	private String field;\n      \n    public Student () {\n        this("NoName", 0, "NoField");\n    }\n\n	public Student (String n, int a, String f) {\n		name = n;\n		age = a;\n		field = f;\n	}\n	\n	public String getName() {\n		return name;\n	}\n		\n	public int getAge() {\n		return age;\n	}\n	\n	public String getField() {\n		return field;\n	}\n}</code></pre>\n<p>&nbsp;</p>\n<p>کد زیر را در فایل Example_3.java قرار دهید و با استفاده از دستور javac این فایل را کامپایل کنید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Example_3 {\n	\n	public static void main(String[] args) {\n		Student student1 = new Student("Ali", 23, "IT");\n		System.out.println("student 1 -&gt; " + student1.getName() + ", " + student1.getAge() + ", " + student1.getField());\n        Student student2 = new Student();\n		System.out.println("student 2 -&gt; " + student2.getName() + ", " + student2.getAge() + ", " + student2.getField());\n	}\n	\n}</code></pre>\n<p>&nbsp;</p>\n<p>خروجی زیر را مشاهده خواهید کرد.</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>student 1 -&gt; Ali, 23, IT\nstudent 2 -&gt; NoName, 0, NoField</code></pre>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع: it3du.ir</h3>\n<p>&nbsp;</p>', '2016-11-03 21:07:00', 22546897, 'images.jpg', 34, 1871, 1, '2017-02-19 12:22:36'),
(137, 'اشاره گر this', 'اشاره گر this و کاربرد های آن در برنامه نویسی جاوا', 'article,article keywords,article keywords2,keywords2', '<h1>اشاره گر this در جاوا چیست و کاربرد آن چیست</h1>\n<p>&nbsp;</p>\n<p>در واقع this یک اشاره گر به آبجکتی از کلاس جاری می باشد.</p>\n<p>زمانی که بخواهیم متغییری در کلاس را اشاره کنیم می توانیم با this این کار را انجام دهیم.</p>\n<p>همچنین با استفاده از this می توانیم کانستراکتور همان کلاس را فراخوانی کنیم.</p>\n<p>برای اینکه واضح تر به ادامه توضیحات ادامه بدیم یک مثال میزنیم</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>public class Example_1 {\n	public Example_1(){\n		this(10);\n	}\n	public Example_1(int i){\n		this(i,++i);\n	}\n	public Example_1(int i, int j){\n		System.out.println("i : "+i + " j : "+j);\n	}\n	public static void main(String[] args){\n		Example_1 t = new Example_1(); // or new Test();\n	}\n}</code></pre>\n<p>&nbsp;</p>\n<p dir="rtl">در اینجا با استفاده از this() می توانیم سازنده های موجود در کلاس را فراخوانی کنیم و اگر سازنده ایی دارای پارامتر باشد برای this آن پارامتر ها را مقدار دهی می کنیم تا به سازنده مورد نظر اشاره کند.</p>\n<p dir="rtl">در ادامه مطلب مثالی از this برای اشاره به یک متغییر ارائه می دهیم...</p>\n<p dir="rtl">&nbsp;</p>\n<pre class="language-java"><code>public class Example_2 {\n	int i;\n	public Example_2(int i){\n		this.i = i;\n		System.out.println(this.i);\n	}\n	public static void main(String[] args){\n		Example_2 t = new Example_2(10);\n		\n	}\n}</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p dir="rtl">در این کلاس یک متغییر سراسری به نام i وجود دارد و سازنده ایی با پارامتری هم نام و هم نوع &nbsp;با متغییر کلاس وجود دارد.</p>\n<p dir="rtl">از متغییر سراسری در سازنده به صورت مستقیم نمی توان استفاده کرد چون هم نام با پارامتر سازنده می باشد و کامپایلر به متغییر محلی اولویت را می دهد. برای استفاده از i در سازنده باید از اشاره گر this استفاده کرد. دستور زیر را در سازنده قرار داده ایم</p>\n<p dir="rtl">&nbsp;</p>\n<pre class="language-java"><code>this.i = i;</code></pre>\n<p>&nbsp;</p>\n<p dir="rtl">معنی این عبارت این است که مقدار پارامتر i را در متغییر i قرار بده که منطقا برای اینکه انتساب درست انجام گیرد باید پارامتر و متغییر هم نوع باشد که در این مثال از نوع صحیح هستند.در واقع با زبان ساده اگر بگوییم به کامپایلر می فهمانیم که منظور ما از i متغییر کلاس می باشد.</p>\n<p dir="rtl">در متد main کلاس، نمونه از کلاس ایجاد کردیم که در هنگام new آبجکت مقدار 10 را به پارامتر سازنده فرستادیم و عمل انتساب و چاپ را انجام دادیم.موفق باشید&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3>منبع: it3du.ir</h3>\n<p>&nbsp;</p>', '2016-11-11 13:31:16', 22546897, 'this-keyword-thumbnail-22323.jpg', 34, 803, 1, '2017-02-19 12:22:52'),
(138, 'رسم مستطیل دایره خط و چند ضلعی در جاوا', 'چگونگی رسم اشکال هندسی در زبان برنامه نویسی جاوا', 'article,article keywords,article keywords2,keywords2', '<h1>رسم اشکال هندسی در جاوا + سورس کد</h1>\n<p>&nbsp;</p>\n<p>در این برنامه با استفاده از کتابخانه های موجود در جاوا اشکالی همچون مستطیل دایره خط و چند ضلعی را در یک فریم رسم می کنیم.</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Polygon;\nimport javax.swing.JFrame;\n/**\n *\n * @author it3du.ir\n */\npublic class Shapes extends JFrame {\n    \n    public Shapes(){\n        super("Shapes - cheknevis.blog.ir");\n        setSize(600, 600);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setLocationRelativeTo(null);\n        \n    }\n    \n    @Override\n    public void paint(Graphics g){\n        super.paint(g);\n        g.setColor(Color.blue);\n        g.drawLine(50, 200, 150, 400);\n        g.setColor(Color.red);\n        g.drawRect(50, 55, 150, 50);\n        g.setColor(Color.green);\n        g.drawOval(100, 120, 150, 150);\n        Polygon poly = new Polygon();\n        poly.addPoint(250, 55);\n        poly.addPoint(250, 100);\n        poly.addPoint(350, 100);\n        g.drawPolygon(poly);\n        poly.addPoint(500, 55);\n        poly.addPoint(500, 100);\n        poly.addPoint(350, 100);\n        g.fillPolygon(poly);\n    }\n    \n    public static void main(String[] args){\n        Shapes s = new Shapes();\n        s.setVisible(true);\n    }\n    \n}</code></pre>\n<p>&nbsp;</p>\n<p>اگر سوالی در رابطه با این کد بود می توانید در قسمت نظرات اعلام کنید</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع : it3du.ir</h3>\n<p>&nbsp;</p>', '2016-11-11 13:50:39', 22546897, 'ch03g-face1.png', 34, 1892, 1, '2017-02-19 12:23:02'),
(139, 'معرفی چند کلاس کاربردی جاوا', 'معرفی کلاس های String, Math و متد های آن ها و نحوه دستکاری داده های رشته ایی در جاوا', 'article,article keywords,article keywords2,keywords2', '<h1>کلاس های Math String و انواع داده اولیه در جاوا</h1>\n<p>&nbsp;</p>\n<p>در این قسمت از سری آموزش های برنامه نویسی جاوا، بعد از مبحث کلاس ها در جاوا چند کلاس سودمند که از آن ها می توانید&nbsp;در برنامه های خود استفاده کنید&nbsp;را بررسی خواهیم کرد. بعضی از کلاس ها که در پکیج java.lang وجود دارند، بدون هیچگونه کار اضافه ایی، خود به خود قابل استفاده در برنامه هستند.</p>\n<p>اما بعضی از کلاس ها در سایر پکیج ها قرار دارند و برای استفاده از آن ها باید پکیج مربوطه آن ها به برنامه با دستور import صریحا به برنامه اضافه&nbsp;شود.</p>\n<p>&nbsp;</p>\n<p>زمانی که شما از یک IDE استفاده می کنید به صورت خودکار ، زمانی که از یک کلاس در برنامه استفاده کنید اگر در پکیجی باشد که آن پکیج به برنامه import نشده باشد، این کار را برای شما انجام می دهد.</p>\n<p>حالا به بررسی کلاس ها می پردازیم.</p>\n<p>&nbsp;</p>\n<h2>کلاس&nbsp;Math در جاوا</h2>\n<p>در پکیج java.util قرار دارد و به صورت خودکار در هر کلاسی قابل استفاده است.</p>\n<p>&nbsp;</p>\n<h4>این کلاس دارای متد ها و متغییر های static هستند که برای عملیات ریاضی و یا تعریف مقادیر ریاضی از آن ها استفاده کرد</h4>\n<p>&nbsp;</p>\n<p>برای مثال این کلاس دو متغییر static به نام های <strong>PI&nbsp;</strong>(عدد پی) و <strong>E</strong>&nbsp;(پایه لگاریتم طبیعی) دارد. چون این مقادیر استاتیک هستند بدون نمونه سازی از کلاس Math و با استفاده از نام کلاس قابل دسترس می باشد.</p>\n<p>متد ها&nbsp;و ثوابت&nbsp;مختلفی در کلاس Math وجود دارد که به شرح مختصر آن ها می پردازیم.</p>\n<p>&nbsp;</p>\n<p>ثابت&nbsp;<strong>PI&nbsp;</strong>و&nbsp;<strong>E&nbsp;</strong>از نوع double هستند.</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>System.out.println("PI: " + Math.PI + " E: " + Math.E);</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">abs(x)</h2>\n<p>برای محاسبه قدر مطلق یک عدد استفاده می شود</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>System.out.println(Math.abs(-15));\nSystem.out.println(Math.abs(-13.56));</code></pre>\n<p>&nbsp;</p>\n<p>پارامتر این متد می تواند عددی از نوع int، float، double و long باشد.</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">ceil(x)</h2>\n<p>یک ورودی از نوع عددی double &nbsp;میگیرد. این متد عدد اعشاری را به بزرگترین عدد صحیح بعدی گرد خواهد کرد. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>System.out.println(Math.ceil(-55.6));\nSystem.out.println(Math.ceil(55.4));</code></pre>\n<p>&nbsp;</p>\n<p>خروجی&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>-55.0\n56.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;exp(x)</h2>\n<p>x از نوع double است. e<sup>x</sup>&nbsp;را برمی گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>exp(x) = 20.085</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;floor(x)</h2>\n<p>x از نوع double است&nbsp;و خروجی آن&nbsp;یک مقدار double است که&nbsp;<strong>بزرگترین صحیح کوچکتر از x&nbsp;</strong>است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>floor (65.78) = 65.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">log(x)&nbsp;</h2>\n<p>x از نوع double است و خروجی متد از نوع double می باشد که <strong>لگاریتم طبیعی x</strong> است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>log (2) = 0.6931</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">log10(x)</h2>\n<p dir="rtl" style="text-align: right;">x از نوع double و در خروجی متد مقداری از نوع&nbsp;double برگردانده می شود که&nbsp;<strong>لگاریتم پایه 10 عدد x</strong> است. مثال زیر را ببینید</p>\n<p dir="rtl" style="text-align: right;">&nbsp;</p>\n<pre class="language-java"><code>log10 (2) = 0.30102</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">max(x,y)</h2>\n<p>x می تواند&nbsp;<strong>هر نوع عددی&nbsp;</strong>باشد و نوع برگشتی متد نیز از همان نوع است. درواقع&nbsp;<strong>بزرگترین مقدار X و y&nbsp;</strong>برگردانده می شود. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>max (45, 25) = 45</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">min(x,y)</h2>\n<p dir="rtl">x می تواند&nbsp;<strong>هر نوع عددی&nbsp;</strong>باشد و نوع برگشتی متد نیز از همان نوع است. درواقع&nbsp;<strong>کوچکترین&nbsp;</strong><strong>مقدار X و y&nbsp;</strong>برگردانده می شود. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>min (45, 25) = 25</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;pow(x, y)</h2>\n<p>x و y از نوع double هستند. نوع double را بر میگرداند که برابر با <strong>x<sup>y</sup></strong> است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>pow (4, 0.5) = 2</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">round(x)</h2>\n<p>مقداری را بر می گرداند که&nbsp;<strong>نزدیک ترین مقدار صحیح به x&nbsp;</strong>است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>round (24.56) = 25\nround (18.35) = 18</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">sqrt(x)</h2>\n<p>x از نوع double است. مقدار double را بر میگرداند که&nbsp;<strong>ریشه دوم x&nbsp;</strong>است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>sqrt (4.0) = 2.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">cos(x)</h2>\n<p>X از نوع double است.&nbsp;<strong>کسینوس x را بر حسب رادیان&nbsp;</strong>بر می گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>cos (0) = 1.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">sin(x)</h2>\n<p>X از نوع double است. <strong>سینوس</strong>&nbsp;<strong>x را بر حسب رادیان&nbsp;</strong>بر می گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>sin (0) = 0.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">tan(x)</h2>\n<p>X از نوع double است. <strong>تانژادنت&nbsp;</strong><strong>x را بر حسب رادیان&nbsp;</strong>بر می گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>tan (0) = 0.0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">random()</h2>\n<p><strong>اعداد تصادفی</strong> بین 0.0 و 1.0 تولید می کند</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">toDegrees(x)</h2>\n<p>x از نوع double است. x بر حسب رادیان است و آن را به درجه تبدیل می کند (تبدیل رادیان به درجه)</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">toRadians(x)</h2>\n<p>x از نوع double است. x بر حسب درجه است و آن را به رادیان تبدیل می کند (تبدیل درجه به رادیان)</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">acos(x)</h2>\n<p>x از نوع double است.&nbsp;<strong>آرک کسینوس x&nbsp;</strong>را محاسبه می کند.</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">asin(x)</h2>\n<p>x از نوع double است.&nbsp;<strong>آرک سینوس x&nbsp;</strong>را محاسبه می کند.</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">atan(x)</h2>\n<p>x از نوع double است.&nbsp;<strong>آرک تانژادنت x&nbsp;</strong>را محاسبه می کند.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>کلاس String</h2>\n<p>این کلاس در پکیج java.lang تعریف شده و به طور خودکار در هر برنامه ایی قابل استفاده است.</p>\n<p>&nbsp;</p>\n<h4>این کلاس برای تعریف رشته به کار می رود و شامل متد های متعددی برای کار کردن بر روی رشته ها است، مثل تست و دستکاری رشته ها</h4>\n<p>&nbsp;</p>\n<p>در ادامه به بررسی متد های این کلاس می پردازیم</p>\n<p>&nbsp;</p>\n<p><strong>شی رشته به صورت های زیر تعریف می گردد</strong></p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String s1;\nString s2 = new String("Hello");\nString s3 = "Hello";</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;دستور اول، متغیر مرجع s1 را ایجاد می کند که به هیچ شی ایی اشاره نمی کند.</p>\n<p>دستور دوم و سوم متغیر مرجع s2 و s3 را ایجاد می کند که درواقع عمل یکسانی هستند و تفاوتی بین آن ها وجود ندارد. هردو متغیر حاوی رشته Hello می باشند.</p>\n<p>&nbsp;</p>\n<p><strong>برای تعریف رشته تهی (رشته ایی به طول صفر) به صورت زیر عمل می کنیم</strong></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p dir="ltr">&nbsp;</p>\n<pre class="language-java"><code>String str = "";</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;نمونه ایی دیگر از اعلان متغیر رشته ایی و مقدار دهی به متغیر</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str1;\nstr1 = "Java Programming";</code></pre>\n<p>&nbsp;</p>\n<p>حالا به مرور بعضی از متد های موجود در کلاس String میپردازیم</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">charAt(index)</h2>\n<p>index از نوع int است. این متد&nbsp;<strong>کارامتر موجود در موقعیت index&nbsp;</strong>را بر میگرداند. کاراکتر های رشته از 0 شماره گذاری می شوند. حالا مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str2 = "Programming with Java";\nSystem.out.println(str2.charAt(3));</code></pre>\n<p>&nbsp;</p>\n<p>خروجی کد بالا به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>g</code></pre>\n<p>&nbsp;</p>\n<p>بنابراین برای خواندن یک کاراکتر در جاوا باید از این متد استفاده کنید</p>\n<p>&nbsp;</p>\n<h4>تمرین: برنامه ایی بنویسید که یک کارکتر از ورودی بخواند و در خروجی چاپ کند</h4>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">indexOf(str)</h2>\n<p>اندیس اولین وقوع کاراکتر ch را در رشته بر می گرداند. اگر چنین کاراکتری در رشته یافت نشد -1 را بر می گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>"Programming with Java"\nstr.indexOf(\'j\') = 17</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">indexOf(str, pos)</h2>\n<p>str&nbsp;از نوع رشته و pos از نوع int است. رشته str را با شروع از موقعیت pos در رشته شروع می کند. اگر str پیدا نشود -1 برگردانده خواهد شد. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>"Programming with Java"\nstr.indexOf("pr", 10) = -1</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">concat(str)</h2>\n<p style="text-align: right;">str از نوع رشته است. رشته ایی را بر میگرداند که str با آن الحاق شده است. یعنی رشته str به انتهای آن الحاق می شود. مثال زیر را ببینید</p>\n<p style="text-align: right;">&nbsp;</p>\n<p style="text-align: right;">&nbsp;</p>\n<pre class="language-java"><code>String myString = "Programming with Java";\nmyString.concat(" is fun.");\nSystem.out.println(myString);</code></pre>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Programming with Java is fun.</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">length()</h2>\n<p>طول رشته را بر می گرداند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Java Programming";\nSystem.out.println(str.length());</code></pre>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>16</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">replace(ch1, ch2)</h2>\n<p>ch1 و ch2 کاراکتری هستند. رشته ایی را بر میگرداند که در آن جای کاراکتر ch1 کاراکتر ch2 قرار گرفته است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Programming with Java";\nstr.concat(\'a\', \'*\');\nSystem.out.println(str);</code></pre>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Progr*mming with J*v*</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;substring(beg)</h2>\n<p>beg از نوع صحیح است. رشته ایی را برمیگرداند که زیر رشته ای از این رشته است و از کاراکتر beg تا انتهای رشته می باشد. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Programming with Java";\nSystem.out.println(str.substring(12));</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>with Java</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;substring(beg, end)</h2>\n<p>beg و end از نوع صحیح هستند. رشته ایی را بر می گرداند که زیر رشته ای از این رشته است و از beg شروع می شود و تا end-1 ادامه دارد. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Programming with Java";\nSystem.out.println(str.substring(0,11));</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Programming</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">toLowerCase()</h2>\n<p>رشته ایی را بر میگرداند که تمامی حروف آن کوچک هستند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Programming with Java";\nSystem.out.println(str.toLowerCase());</code></pre>\n<p>&nbsp;&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>programming with java</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">toUpperCase()</h2>\n<p>رشته ایی را بر میگرداند که تمامی حروف آن بزرگ&nbsp;هستند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "Programming with Java";\nSystem.out.println(str.toUpperCase());</code></pre>\n<p>&nbsp;&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>PROGRAMMING WITH JAVA</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">equals(object)</h2>\n<p>object شی ای است که باید مورد مقایسه انجام گیرد. اگر با هم برابر باشند، true وگرنه false برگردانده می شود. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str1 = "It3du";\nString str2 = "It3du";\nSystem.out.println(str1.equals(str2));</code></pre>\n<p>&nbsp;&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>true</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">equalsIgnoreCase(object)</h2>\n<p>این متد همانند متد equals است. با این تفاوت که بین حروف بزرگ و کوچک تفاوت قائل نمی شود. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str1 = "It3du";\nString str2 = "It3DU";\nSystem.out.println(str1.equals(str2));\nSystem.out.println(str1.equalsIgnoreCase(str2));</code></pre>\n<p>&nbsp;&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>false\ntrue</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">compareTo(str)</h2>\n<p>str رشته ایی است که باید مقایسه شود. اگر این دو رشته با هم <strong>برابر</strong> باشند این متد مقدار <strong>صفر</strong> بر میگرداند ، اگر str از آن رشته <strong>بزرگ تر</strong> باشد مقدار <strong>منفی</strong> و اگر str از آن <strong>کوچک تر</strong> باشد، مقداری <strong>مثبت</strong> بر میگرداند. مثال زیر را ببینید</p>\n<p dir="ltr">&nbsp;</p>\n<pre class="language-java"><code>String str1 = "It3du";\nString str2 = "It3du";\nSystem.out.println(str1.compareTo(str2));</code></pre>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;compareToIgnoreCase(str)</h2>\n<p>همانند متد compareTo می باشد. با این تفاوت که بین حروف بزرگ و کوچک تفاوتی قائل نمی شود. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>String str = "H";\nSystem.out.println(str.compareTo("h"));\nSystem.out.println(str.compareToIgnoreCase("h"));</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;خروجی متد به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>-32\n0</code></pre>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">&nbsp;isEmpty()</h2>\n<p>اگر رشته تهی باشد مقدار true وگرنه مقدار false را بر می گرداند.</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">lastIndexOf(ch)</h2>\n<p>شبیه متد indexOf است با این تفاوت که جستجو از آخر صورت می گیرد</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">lastIndexOf(str, pos)</h2>\n<p>شبیه indexOf با دو پارامتر در ورودی است . با این تفاوت که جستجو از آخر صورت می گیرد</p>\n<p>&nbsp;</p>\n<h2 dir="ltr" style="text-align: right;">valueOf(x)</h2>\n<p>x می تواند int، double، float، long یا char باشد. مقادیری از نوع آرگومان را به رشته تبدیل می کند. مثال زیر را ببنید. آرگومان ورودی از نوع صحیح است که تبدیل به رشته می شود</p>\n<p>&nbsp;</p>\n<pre class="language-java" dir="ltr"><code>String intValueString = String.valueOf(169);</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>&nbsp;</h2>\n<h2>مقایسه رشته ها در جاوا</h2>\n<p>یکی از متداول ترین کار ها در مورد رشته ها، مقایسه آن ها است.</p>\n<p>&nbsp;</p>\n<h4>منظور از مقایسه رشته ها چیست؟ &nbsp;رشته ها به صورت کاراکتر به کاراکتر با هم مقایسه می شوند. بدیهی هست که دو رشته وقتی با هم یکسان هستند که اولا طول آن ها و ثانیا کارکتر های متناظر آن ها با هم یکسان باشند.</h4>\n<p>&nbsp;</p>\n<p>دستورات&nbsp;زیر را در نظر بگیرید</p>\n<p>&nbsp;</p>\n<pre class="language-java"><code>System.out.println(aName.equals(anotherName));\nSystem.out.println(aName.equalsIgnoreCase(anotherName));\nSystem.out.println(aName.equals("Ali"));\nSystem.out.println(anotherName.equalsIgnoreCase("ali"));</code></pre>\n<p>&nbsp;</p>\n<p>خروجی به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>false\ntrue\ntrue\ntrue</code></pre>\n<p>&nbsp;</p>\n<p>همچنین از متد های compareTo و compareToIgnoreCase می توانید استفاده کنید</p>\n<p>&nbsp;</p>\n<p>با ادامه قسمت های آموزشی جاوا همراه ما باشید.</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3>منبع: it3du</h3>\n<p>&nbsp;</p>\n<p>&nbsp;</p>', '2016-12-04 20:44:31', 22546897, 'java-thumbnail-blog.jpg', 34, 1008, 1, '2017-02-19 12:27:13'),
(146, 'تعریف متغییر سراسری در codeigniter', 'چگونه در فریمورک codeigniter یک متغییر سراسری تعریف کنیم که در کل برنامه قابل دسترس باشد', 'article,article keywords,article keywords2,keywords2', '<h1>چگونه&nbsp;در فریمورک کدایگنایدر یک متغییر سراسری تعریف کنیم</h1>\n<p>فریمورک codeigniter یک فریمورک مبتنی بر زبان برنامه نویسی PHP می باشد که بر اساس معماری MVC پیاده سازی شده است.</p>\n<p>شما می توانید بنا بر نیاز خود کار های مختلفی در این فریمورک انجام دهید.</p>\n<p>یکی از نیاز هایی که می توان با آن مواجه شد، تعریف متغییر سراسری می باشد که در اثنای اجرای فریمورک در دسترس باشد.</p>\n<p>برای ثبت یک ثابت و متغییر سراسری می باشد در مسیر زیر نسبت به تعریف متغییر اقدام کنید</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>application/config/constants.php</code></pre>\n<p>&nbsp;</p>\n<p>برای مثال می خواهیم آدرس سایت را در متغییر سراسری به نام SITE_PATH قرار دهیم. بنابراین در فایل constants.php به صورت زیر آن را تعریف میکنیم</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>define(\'SITE_PATH\', \'http://www.it3du.ir\');</code></pre>\n<p>&nbsp;</p>\n<p>حالا این متغییر در کل برنامه قابل دسترس می باشد.</p>\n<p>دقت داشته باشید ترتیب اجرای فایل ها به صورت زیر است</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>/index.php\n/system/core/Codeigniter.php\n/system/core/Common.php\n/application/constants.php\n</code></pre>\n<p>&nbsp;</p>\n<p>بنابراین فایل constants.php قبل از controller ها و view ها لود می شوند و در آن ها قابل دسترسی می باشند.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع:<a title="آموزش برنامه نویسی" href="../../"> it3du.ir</a></h3>\n<p>&nbsp;</p>', '2017-05-09 22:23:36', 22546897, 'codeigniter-thumbnail.jpg', 36, 353, 1, '2017-05-09 22:45:00'),
(147, 'مفهوم hook در codeigniter', 'hook چیست و کاربرد آن در برنامه نویسی و فریمورک codeigniter به چه صورت است و چه فایده و مزایایی دارد', 'article,article keywords,article keywords2,keywords2', '<h1>hook چیست و مزایای استفاده از آن چه می باشد</h1>\n<p>&nbsp;</p>\n<p>در واقع فریمورک ها اگر انعطاف پذیری را نداشتند، به این اندازه محبوب نمی شدند. چون بنا بر نیازمندی های شما ممکن است امکانات خاص و ویژه ایی را بخواهید که اگر فریمورکی که از آن استفاده می کنید آن را نداشته باشد برای شما ناقص محسوب می شود.</p>\n<p>اگر codeigniter فقط به شما امکاناتی از قبیل&nbsp;</p>\n<ul style="list-style-type: circle;">\n<li>routing</li>\n<li>controller ها</li>\n<li>model ها</li>\n<li>view ها</li>\n</ul>\n<p>را بدهد درواقع یک میکروفریمورک محسوب می شود. اما فریمورک ها به شما این اجازه را می دهند که علاوه بر امکانات موجود قادر به توسعه آن هرچند در هسته فریمورک باشید. مثلا می توانید کتابخانه های شخصی بنویسید و از آن در پروژه های دیگر خود استفاده کنید. یا با اشتراک گذاشتن آن ها دیگر برنامه نویس ها بتوانند از آن کتابخانه استفاده کنند.</p>\n<p>برای مثال کتابخانه ایی نوشتید برای تبدیل تاریخ میلادی به شمسی. با اضافه کردن آن به سایر پروژ هایتان می توانید از آن استفاده کنید یا با به اشتراک گذاری آن ها سایر برنامه نویس ها می توانند از آن ها استفاده کنند.</p>\n<p>&nbsp;</p>\n<h2>و اما مفهوم هوک چیست؟</h2>\n<p>&nbsp;</p>\n<p>درواقع hook ویژگی می باشد که این امکان را به شما می دهد بدون هک (دستکاری) هسته فریمورک فعالیت هایی را در زمان های مشخص انجام دهید.</p>\n<p>برای مثال شاید بخواهید اسکریپتی قبل از اجرا یا بعد از اجرای هر کنترلر شما فراخوانی شود.&nbsp;در واقع این امکان را دارید که تریگری به یک کد در یک محل دیگر از سایت شما زده شود.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>برای اینکه شما بتوانید از هوک استفاده کنید باید در آدرس زیر&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>application/config/config.php</code></pre>\n<p>&nbsp;</p>\n<p>مقدار enable_hook را برابر TRUE قرار دهید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$config[\'enable_hook\'] = TRUE;</code></pre>\n<p>&nbsp;</p>\n<h2>تعریف یک هوک</h2>\n<p>&nbsp;</p>\n<p>هوک ها باید در آدرس زیر تعریف شوند</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>applicatio/config/hooks.php</code></pre>\n<p>&nbsp;</p>\n<p>همانطور که گفتیم هوک ها به اسکریپتی در محلی از سایت تریگر میشوند. بنابر این برای تعریف یک هوک باید در فایل hooks.php یک هوک را تعریف کنیم</p>\n<p>ساختار یک هوک به شکل زیر است</p>\n<p>برای تعریف hook ابتدا به آدرس زیر رفته</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>application/config/hooks.php</code></pre>\n<p>&nbsp;</p>\n<p>حالا&nbsp;کد زیر را برای تعریف یک هوک به فایل hooks.php اضافه می کنیم</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$hook[\'pre_controller\'] = array (\n    \'class\'    =&gt; \'MyClass\',\n    \'function\' =&gt; \'myFunction\',\n    \'filename\' =&gt; \'MyClass.php\',\n    \'filepath\' =&gt; \'hooks\',\n    \'params\'   =&gt; array(\'param1\', \'param2\', \'param3\')\n);</code></pre>\n<p>&nbsp;</p>\n<p>در مثال بالا hook point (در واقع منظور رویدادی که باعث تریگر شدن هوک می شود) <strong>pre_controller</strong> است. یعنی قبل از اینکه کنترلر مربوطه فراخوانی شود</p>\n<ol>\n<li>متد myFunction</li>\n<li>از کلاس MyClass</li>\n<li>فایل MyClass.php</li>\n<li>موجود در آدرس hooks</li>\n<li>با پارامتر های param1 ، param2 و param3 (پارامتر ها اختیاری هستند)</li>\n</ol>\n<p>فراخوانی می شود.</p>\n<p>&nbsp;</p>\n<p>حالا باید با توجه به تعریف هوک ، فایل مورد نظر با کلاس تعریف شده و متد تعریف شده را در دایرکتوری تعریف شده ایجاد کنیم. در مثال بالا ما فایل مورد نظر با مشخصات تعریف شده را در دایرکتوری زیر تععین کردیم. اگر این دایرکتوری وجود ندارد آن را ایجاد کنید</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>application/hooks</code></pre>\n<p>&nbsp;</p>\n<p>بنابراین فایل MyClass.php را در دایرکتوری بالا ایجاد می کنیم&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>application/hooks/MyClass.php</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>استفاده از lambda ، anonymouse functions با سینتکس ساده</h2>\n<p>&nbsp;</p>\n<p>می توانید هوکی داشته باشید که به فایلی اشاره نکند. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$hook[\'pre_controller\'] = function() {\n    /* do somthing here */\n}</code></pre>\n<p>&nbsp;</p>\n<h2>Hook Points ها</h2>\n<p>&nbsp;</p>\n<p>منظور از hook points در واقع مناطقی ، یا محلی می باشد که قرار است رویداد هوک در آن زمان اتفاق بیافتد. codeigniter هوک پوینت های زیر را در نظر گرفته است که اسامی آن ها زمان اتفاق افتادن آن ها را می گوید</p>\n<p>&nbsp;</p>\n<ul>\n<li>pre_system</li>\n<li>pre_controller</li>\n<li>post_controller_constructor</li>\n<li>post_controller</li>\n<li>display_override</li>\n<li>cashe_override</li>\n<li>post_system</li>\n</ul>\n<p>&nbsp;</p>\n<p><strong>pre_system&nbsp;</strong>در این زمان فقط benchmark و کلاس hook لود شده است. هیچ فعالیت یا پردازش دیگری مانند روتینگ یا سایر فعالیت ها لود نشده است.</p>\n<p>&nbsp;</p>\n<p><strong>pre_controller &nbsp;</strong>قبل از هر کنترلر شما اجرا میشود. (برای هر متد از کلاس کنترلر). تمامی کلاس های روتینگ، امنیتی و پایه قبل از اجرای این نقطه لود شده اند. برای فراخوانی هر متد اتفاق می افتد.</p>\n<p>&nbsp;</p>\n<p><strong>post_controller_constructor&nbsp;</strong>در واقع زمانی که از کنترلر شما نمونه ایی ایجاد می شود این نقطه برای هوک در نظر&nbsp;گرفته می شود و پس از پایان نمونه سازی اسکریپت اجرا میشود. یعنی این نقطه قبل از pre_controller اجرا می شود.</p>\n<p>&nbsp;</p>\n<p><strong>post_controller&nbsp;</strong>بعد از پایان کامل کنترلر اجرا می شود</p>\n<p>&nbsp;</p>\n<p>در ادامه باز هم از ویژگی های hook ها مانند فراخوانی چند اسکریپت برای یک هوک پوینت مشابه و مثالی عملی از آن در codeigniter را در سایت قرار خواهیم داد.</p>\n<p>&nbsp;</p>\n<h2>مزایای استفاده از هوک</h2>\n<p>&nbsp;</p>\n<p>مزایای اصلی هوک، توسعه هسته فریمورک بدون دستکاری هسته آن است. که همین نکته مهمترین قوت استفاده از آن است. چرا که اگر بخواهید فریمورک خود را از ورژنی به ورژن بالاتر آپدیت کنید باید تمام دایرکتوری system ورژن جدید رو با دایرکتوری system موجود در ورژن جاری را تغییر دهید و تمامی تغییرات قبلی را در دایرکتوری system جدید اعمال کنید که سخت و طاقت فرسا می شود!</p>\n<p>و چون تمامی فایل های هوک و تنظیمات آن در دایرکتوری application شما قرار دارد . نیاز به نغییرات در برنامه خود ندارید.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h4>می توانید انتشار قسمت ها جدید آموزش برنامه نویسی و به روز رسانی های&nbsp;جدید سایت را از <a title="کانال تلگرام سایت it3du" href="https://telegram.me/it3du">کانال تلگرام</a> ما دنبال کنید &nbsp;و یا از قسمت انتهایی سایت ، آدرس <a title="مرجع آموزش برنامه نویسی جاوا و طراحی وب" href="../../">it3du</a>&nbsp;را در سایر شبکه های اجتماعی پیدا کنید</h4>\n<p>&nbsp;</p>\n<h3>منبع:<a title="آموزش برنامه نویسی" href="../../"> it3du.ir</a></h3>\n<p>&nbsp;</p>', '2017-05-09 22:55:37', 22546897, 'codeigniter-thumbnail.jpg', 36, 464, 1, '2017-05-10 00:16:32'),
(148, 'تابع eval در PHP', 'این تابع رشته ای به عنوان کد php دریافت می کند و بعد از ارزیابی آن ، رشته به صورت کد php اجرا می شود', 'article,article keywords,article keywords2,keywords2', '<h1>ارزیابی رشته ها با تابع eval در PHP</h1>\n<p>این تابع رشته ای را به عنوان کد PHP ارزیابی می کند. به عنوان مثال دستور زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>eval("echo \'PHP Programming\';");</code></pre>\n<p>&nbsp;</p>\n<p>این تابع محتویات رشته را گرفته آن را اجرا می کند. خروجی این دستور مثل خروجی دستور زیر می باشد</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>echo \'PHP Programming\';</code></pre>\n<p>&nbsp;</p>\n<p>درواقع رشته ورودی در این تابع کد PHP در نظر گرفته می شود و اجرا خواهد شد. برای درک بهتر مثال زیر را نگاه کنید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$a = "echo \'";\n$b = "PHP Programming\';";\neval($a . $b);</code></pre>\n<p>&nbsp;</p>\n<p>با الحاق رشته های متغییر a و &nbsp;b دستور زیر به صورت رشته به ورودی متد eval می رود</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>echo \'PHP Programming\';</code></pre>\n<p>&nbsp;</p>\n<p>و رشته PHP Programming در خروجی چاپ می شود.</p>\n<p>تابع eval() موارد کاربردی متعددی دارد. به عنوان مصال ممکن است بخواهید بلوکی از کد را در پایگاه داده ذخیره کنید، سپس آن ها را بازیابی کرده با eval اجرا کنید. ممکن است بخواهید کدی را در یک حلقه تکرار ایجاد کنید و سپس با تابع eval آن را اجرا نمایید. با استفاده از eval می توان کد موجود را نوسازی کرد.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3>منبع : it3du</h3>\n<p>&nbsp;</p>', '2017-07-26 15:19:36', 22546897, 'php-logo.png', 37, 573, 1, '2017-07-26 15:39:24'),
(150, 'الگوریتم مرتب سازی تعویضی', 'این پست به بررسی و ارایه سورس کد الگوریتم مرتب سازی تعویضی در زبان های برنامه نویسی می پردازد ', 'article,article keywords,article keywords2,keywords2', '<h1>سورس کد الگوریتم مرتب سازی تعویضی(Exchange Sort)</h1>\n<p>&nbsp;</p>\n<p>این الگوریتم دارای <strong>دو پارامتر ورودی </strong>می باشد. <strong>آرایه</strong> و <strong>تعداد آرایه</strong> دو پارامتر ورودی هستند. در سورس های زیر فرض بر این گرفته شده است که آرایه شامل اعداد صحیح می باشند. <strong>خروجی الگوریتم </strong>یک آرایه مرتب شده است.</p>\n<p>فرض بر اینکه آرایه ورودی با تعداد عناصر n و نام s را برای مرتب سازی داریم. سورس به صورت زیر است</p>\n<p>&nbsp;</p>\n<h2>الگوریتم مرتب سازی تعویضی در زبان PHP</h2>\n<p>&nbsp;</p>\n<pre class="language-php"><code>function exchange_sort($n, $s) {\n    for ($i = 0; $i &lt; $n-1; $i++) {\n        for ($j = $i + 1; $j &lt; $n; $j++) {\n            if ($s[$j] &lt; $s[$i]) {\n                // exchange $numbers[$i] and $numbers[j]\n                $temp = $s[$i];\n                $s[$i] = $s[$j];\n                $s[$j] = $temp;\n            }\n        }\n    }\n    return $s;\n}</code></pre>\n<p>&nbsp;</p>\n<h2>الگوریتم مرتب سازی تعویضی در زبان JAVA</h2>\n<p>&nbsp;</p>\n<pre class="language-java"><code>/**\n *\n * @author http://www.it3du.ir\n */\npublic class ExchangeSortJava {\n    \n    public static void main(String[] args) {\n        ExchangeSortJava obj = new ExchangeSortJava();\n        int[] s = {30,10,32,44,15};\n        for (int i : s) {\n            System.out.print(i + " ");\n        }\n        System.out.println("");\n        obj.exchangeSort(5,s);\n        for (int i : s) {\n            System.out.print(i + " ");\n        }\n    }\n    \n    public void exchangeSort(int n, int s[]) {\n        for (int i = 0; i &lt; n -1; i++) {\n            for (int j = i+1; j &lt; n; j++) {\n                if(s[i] &gt; s[j]) {\n                    // Exchange s[i] and s[j]\n                    int temp = s[i];\n                    s[i] = s[j];\n                    s[j] = temp;\n                }\n            }\n        }\n    }\n    \n}</code></pre>\n<p>&nbsp;</p>\n<h2>الگوریتم مرتب سازی تعویضی در زبان PYTHON</h2>\n<p>&nbsp;</p>\n<pre class="language-python"><code>def exchangeSort (n, s) :\n    for i in range(0, len(s)-1):\n        for j in range(i+1, len(s)):\n            if s[i] &gt; s[j]:\n                # Exchange s[i] and s[j]\n                temp = s[i]\n                s[i] = s[j]\n                s[j] = temp\n    \n\n	\nnumbers = [5,20,3,88,9]\nresult = exchangeSort(5, numbers)\nprint(numbers)</code></pre>\n<p>&nbsp;</p>\n<h2>الگوریتم مرتب سازی تعویضی در زبان C</h2>\n<p>&nbsp;</p>\n<pre class="language-c"><code>void exchangeSort(int n, int s[])\n{\n    int i  = 0;\n    int j = 0;\n    for(i; i &lt; n; i++)\n    {\n        for(j = i+1; j &lt; n; j++)\n        {\n            if(s[i] &gt; s[j])\n            {\n                // Exchange s[i] and s[j]\n                int temp = s[i];\n                s[i] = s[j];\n                s[j] = temp;\n            }\n        }\n    }\n}</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><a title="الگوریتم مرتب سازی " href="../../">منبع : it3du.ir</a></p>\n<p>&nbsp;</p>', '2017-09-13 15:20:48', 22546897, 'exchange-sort-thumbnail-post-1.jpg', 38, 558, 1, '2017-09-13 16:23:59');
INSERT INTO `articles` (`article_id`, `article_title`, `article_precontent`, `article_keywords`, `article_content`, `article_date`, `article_author`, `article_thumbnail`, `article_category`, `article_view`, `article_status`, `article_last_modified`) VALUES
(151, 'متد abs در PHP', 'کاربرد و عملکرد متد abs  در زبان برنامه نویسی PHP', 'article,article keywords,article keywords2,keywords2', '<h1>قدر مطلق گرفتن از یک عدد در PHP</h1>\n<p>&nbsp;</p>\n<p>این متد مقدار مثبت یک عدد را بر میگرداند. اگر عدد پاس داده شده به این متد اعشاری (float) باشد همان عدد اعشاری برگردانده می شود در غیر اینصورت عدد صحیح است. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>echo abs(6.7) . "&lt;br&gt;";\necho abs(-6.7) . "&lt;br&gt;";\necho abs(-3) . "&lt;br&gt;";\necho abs(3);</code></pre>\n<p>&nbsp;</p>\n<p>خروجی کد بالا به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>6.7\n6.7\n3\n3</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p>منبع: <a title="آموزش برنامه نویسی و طراحی وب" href="../../">it3du.ir</a></p>\n<p>&nbsp;</p>', '2017-09-13 23:46:52', 22546897, 'php-logo.png', 37, 257, 1, '2017-09-13 23:53:32'),
(152, 'حلقه while در PHP', 'حلقه while چیست و چگونه از آن در PHP استفاده کنیم و مثال هایی از آن در PHP', 'article,article keywords,article keywords2,keywords2', '<h1>حلقه while در زبان برنامه نویسی PHP</h1>\n<p>در PHP چهار ساختار حلقه ایی وجود دارد که از آنها برای اجرای چند باره یک بلاک&nbsp;کد استفاده می شود. در این مقاله به بررسی حلقه while می پردازیم</p>\n<p>&nbsp;</p>\n<p>حلقه while تنها زمانی اجرا می شود که شرط آن ارزش درستی داشته باشد و اجرای آن تا زمانی ادامه پیدا می کند که که شرط صحیح باشد. شرط حلقه while در ابتدای هر بار تکرار بررسی می شود</p>\n<p>&nbsp;</p>\n<p>مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$num = 0;\n\nwhile ($num &lt; 5) {\n    echo $num++;\n}</code></pre>\n<p>&nbsp;</p>\n<p>کد بالا متغیری به نام num را ایجاد می کند و مقدار اولیه 0 را به آن می دهد. زمانی که به حلقه while می رسد شرط حلقه را بررسی می کند. شرط حلقه برابر است با کوچکتر بودن متغیر num از 5. بنابراین چون در ابتدای کار مقدار 0 را دارد دستورات موجود در بدنه حلقه اجرا می شود. در هربار اجرای دستورات بدنه while مقدار num یک واحد پس از چاپ افزایش می یابد و زمانی که مقدار num به 5 رسید&nbsp; چون شرط حلقه ارزش نادرستی دارد از حلقه بیرون می آید.</p>\n<p>&nbsp;</p>\n<p>شکل کلی دستور while به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>while (condition) {\n    // statements\n}</code></pre>\n<p>&nbsp;</p>\n<p>همانطور که گفته شد condition شرط حلقه که برای اجرای دستورات باید true باشد و statements دستورات موجود در بدنه حلقه که در صورت درست بودن شرط حلقه باید اجرا شوند</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<p><strong>مثال زیر را در نظر بگیرید</strong></p>\n<p>فرض کنید آرایه ایی از اعداد صحیح داریم. میخواهیم بدانیم در این آرایه عدد n وجود دارد یا خیر. برای این کار از حلقه while استفاده می کنیم</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$n = 0;\n$arr = [1,2,3,4,5,6,7,8,9,10];\n$result = 0;\n$i = 0;\n\nwhile ($i &lt; 10) {\n	if ($arr[$i] == $n) {\n		$result = 1;\n		break;\n	} else {\n		$i++;\n	}\n}\n\n\nif($result) {\n	echo "$n exist in array";\n} else {\n	echo "$n not exist in array";\n}</code></pre>\n<p>&nbsp;</p>\n<p>متغیر n مقدار مورد نظر برای جستجو می باشد</p>\n<p>متغیر arr آرایه ایی از اعداد صحیح می باشد</p>\n<p>متغیر i اندیس آرایه می باشد که در هر بار اجرای while یک واحد به آن اضافه می شود</p>\n<p>متغیر result که مقدار اولیه 0 را دارد و اگر مقدار n در آرایه موجود باشد مقدار آن به 1 تغییر می کند و به این معنا است که مقدار مورد نظر در آرایه وجود دارد</p>\n<p>شرط حلقه کوچکتر بودن متغیر i که اندیس آرایه می باشد است که i باید از تعداد خانه های آرایه کوچکتر باشد. به دلیل پیچیده نشدن کد ما مقدار 10 را قرار دادیم ولی می توان شرط حلقه را به صورت زیر تغییر داد تا در صورت کم یا زیاد شدن تعداد خانه های آرایه کد با اررو مواجه نشود</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>while ($i &lt; count($arr)) {\n    ...\n    ...\n}</code></pre>\n<p>&nbsp;</p>\n<p>متد count در php سایز آرایه را بر میگرداند</p>\n<p>&nbsp;</p>\n<h3>منبع: <a title="آموزش برنامه نویسی و طراحی وب" href="../../">it3du.ir</a></h3>\n<p>&nbsp;</p>\n<p>&nbsp;</p>', '2018-01-28 17:35:28', 22546897, 'php-logo.png', 37, 135, 1, '2018-01-28 18:23:43'),
(156, 'متغییر ها در PHP', 'از متغیر ها برای ذخیره کردن داده ها مثل اعداد و عبارات رشته ای استفاده می شود. متغییر ها در PHP', 'article,article keywords,article keywords2,keywords2', '<h1>تعریف متغییر و کاربرد متغییر ها در برنامه نویسی PHP</h1>\n<p>&nbsp;</p>\n<p>همانطور که اشاره کردیم از متغییر ها برای ذخیره کردن داده ها مانند اعداد و رشته ها یا string در طول اجرای برنامه استفاده می کنیم.</p>\n<p>برای اینکه بتوایم در زمان اجرا چندین بار از داده مورد نظر استفاده کنیم باید آن را در یک متغییر قرار دهیم.</p>\n<p>در زبان برنامه نویسی PHP به دلیل اینکه یک زبان اسکریپتی می باشد زمانی که یک متغیر ایجاد میکنید نوع آن زیاد مهم نیست. یعنی شما متغیری ایجاد می کنید و مقدار اولیه ۱۰ را به آن اختصاص می دهید. و در ادامه مقدار رشته ای "Test" را به آن اختصاص می دهید. در زمان کامپایل هیچ اخطاری به شما داده نمی شود. در زبان های برنامه نویسی اسکریپتی پیچیدگی و محدودیت های نوع داده در متغییر برداشته شده است. هرچند که می توانید برای یک متغییر نوع داده تعیین کنید. در PHP نسخه 7 این تغییرات دیده می شود و در ادامه به بررسی آن ها خواهیم پرداخت.</p>\n<p>&nbsp;</p>\n<h2>تعریف متغییر ها</h2>\n<p>&nbsp;زمانی که میخواهید یک متغییر در PHP تعریف کنید باید یک شناسه یا Identifier برای آن مشخص کنید که نام آن متغییر محسوب می شود. یعنی باید برای آن متغییر یک نام تعریف کنید که هر زمان در صورت نیاز به مقدار آن با نام آن متغییر قابل دسترس باشد. برای تعریف یک متغییر ابتدا کارکتر $ و سپس نام متغییر یا همان Identifier را می نویسیم. مثلا برای تعریف متغییری با نام amount به صورت زیر عمل می کنیم</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount;</code></pre>\n<p>&nbsp;</p>\n<p>کد بالا متغییری به نام amount ایجاد کرد. اما این متغییر هیچ مقداری ندارد و null می باشد. شما می توانید در زمان تعریف یک متغییر آن را&nbsp;<strong>مقدار دهی اولیه&nbsp;&nbsp;</strong>(Initialized)&nbsp;نیز کنید.</p>\n<p>برای اینکار از <strong>عملگر تخصیص =</strong> استفاده می کنیم. کد زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = 10;</code></pre>\n<p>&nbsp;</p>\n<p>پس از تعریف متغییر می توان با استفاده از نام آن به مقدار آن دسترسی پیدا کرد. حالا با استفاده از دستور echo&nbsp; مقدار متغییر را در خروجی صفحه وب چاپ کنیم. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php" dir="ltr"><code>$amount = 1000;\necho $amount;</code></pre>\n<p>&nbsp;</p>\n<p>خروجی شما به صورت زیر خواهد بود</p>\n<p>&nbsp;</p>\n<pre class="language-markup" dir="ltr"><code>1000</code></pre>\n<p>&nbsp;</p>\n<h4>به یاد داشته باشید که PHP نسبت به بزرگ و کوچیک بودن نام متغییر ها و همچنین متد ها حساس است. یعنی متغییر amount با Amount متفاوت است. همچنین نام متغییر می تواند شامل حروف اعداد و خط زیر _ باشد ولی حرف اول متغییر نمی تواند با حروف شروع شود</h4>\n<p>&nbsp;</p>\n<h2>انواع داده ها</h2>\n<p>&nbsp;</p>\n<p>زبان برنامه نویسی PHP از نظر نوع داده زبان قدرتمندی نیست و این به این معنی می باشد که نوع داده ای که یک متغییر می تواند زخیره کند مشخص نیست و بسته به مقداری که به آن تخصیص می دهید به صورت خودکار تغییر می کند. دستورات زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = 10; // integer\n$amount = 1.5; // float</code></pre>\n<p>&nbsp;</p>\n<p>در خط اول متغییر amount مقدار صحیح (int) را داشت و در خط دوم مقدار اعشاری (float) را دارد. بنابراین با این ویژگی دانستن نوع داده در خیلی از مواقع نیاز نیست&nbsp;با این حال در بعضی از مواقع ضروری است که نوع داده را بدانیم.</p>\n<p>در جدول زیر 9 نوع داده ای موجود در PHP را جمع آوری کرده ایم</p>\n<p>&nbsp;</p>\n<table style="margin-left: auto; margin-right: auto;">\n<tbody>\n<tr style="height: 13px;">\n<td style="height: 13px;">int</td>\n<td style="height: 13px;">عددی</td>\n<td style="height: 13px;">عدد صحیح (int)</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">float</td>\n<td style="height: 13px;">عددی</td>\n<td style="height: 13px;">عدد اعشاری (float)</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">bool</td>\n<td style="height: 13px;">عددی</td>\n<td style="height: 13px;">مقدار بولی یا boolean</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">string</td>\n<td style="height: 13px;">عددی</td>\n<td style="height: 13px;">دنباله ای از کاراکتر ها</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">array</td>\n<td style="height: 13px;">مرکب</td>\n<td style="height: 13px;">مجموعه ای از مقادیر</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">object</td>\n<td style="height: 13px;">مرکب</td>\n<td style="height: 13px;">نوع داده ای که کاربر معرفی میکند</td>\n</tr>\n<tr style="height: 13.4688px;">\n<td style="height: 13.4688px;">resource</td>\n<td style="height: 13.4688px;">ویژه</td>\n<td style="height: 13.4688px;">منبع خارجی</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">callable</td>\n<td style="height: 13px;">ویژه</td>\n<td style="height: 13px;">تابع یا متد</td>\n</tr>\n<tr style="height: 13px;">\n<td style="height: 13px;">null</td>\n<td style="height: 13px;">ویژه</td>\n<td style="height: 13px;">تهی یا بدون مقدار</td>\n</tr>\n</tbody>\n</table>\n<p>&nbsp;</p>\n<h2>نوع Integer در PHP</h2>\n<p>&nbsp;</p>\n<p>یک Integer یک عدد صحیح می باشد که می توان آن را به صورت دسیمال ( مبنای 10 ) هگزا دسیمال ( مبنای 16 ) اکتال ( مبنای 8 ) یا باینری ( مبنای 2 ) نوشت.</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = 1234; // decimal\n$amount = 0b10; // binary\n$amount = 0123; // octal\n$amount = 0x1A; // hexadecimal</code></pre>\n<p>&nbsp;</p>\n<p>نوع داده صحیح هم میتوانند مثبت و هم منفی باشند. دامنه اعداد صحیح بستگی به اندازه کلمه سیستم (System Word Size) دارد. برای مثال در یک سیستم ۳۲ بیتی بزرگترین مقدار به صورت زیر می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>2^32-1</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>نوع اعشاری یا float در PHP</h2>\n<p>&nbsp;</p>\n<p>برای ذخیره اعداد اعشاری&nbsp;</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = 10.56;\n$amount = 3e2; // 300 or 3*10^2</code></pre>\n<p>&nbsp;</p>\n<h2>نوع Bool در PHP</h2>\n<p>&nbsp;</p>\n<p>یک مقدار بولی که شامل true و false می باشد. یعنی همان 0 و 1 منطقی که یا درست است یا نا درست</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = true;\n$amount = false;</code></pre>\n<p>&nbsp;</p>\n<h2>نوع null در PHP</h2>\n<p>&nbsp;</p>\n<p>برای تعریف متغییری که هیچ مقداری ندارد ( پوچ ) استفاده می شود</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$amount = null;\n$amount = NULL;</code></pre>\n<p>&nbsp;</p>\n<p>این نوع از داده بسته به جایی که آن را استفاده می کنیم تغییر می کند.اگر آن را به صورت Bool مقایسه کنیم مقدار false می باشد. اگر به صورت عددی ارزیابی کنیم معادل 0 است و در صورت ارزیابی به صورت رشته ای نیز معادل " " می باشد</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$null_var = NULL;\n$amount = $null_var + 0; // 0\n$amount = $null_var == true; // false\necho $null_var; // " "</code></pre>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h2>مقادیر پیش فرض در PHP</h2>\n<p>&nbsp;</p>\n<p>در PHP می توان از متغییر هایی که مقداری به آن ها اختصاص داده نشده است یا اصلا تعریف نشده ان استفاده کرد. در این صورت مقدار null به این متغییر ها تخصیص داده می شود. بدون تعریف متغییر amount آن را با echo چاپ می کنیم. دستورات زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>echo $amount;</code></pre>\n<p>&nbsp;</p>\n<p>با توجه به این که نه این متغییر تعریف شده و نه مقدار دهی اولیه شده است و نه در طول اجرای برنامه مقداری به آن اختصاص داده شده است PHP یک Notice یا یک آگهی به ما می دهد</p>\n<p>&nbsp;</p>\n<pre class="language-markup"><code>Notice: Undefined variable: amount in /opt/lampp/htdocs/undefined.php on line 3</code></pre>\n<p>&nbsp;</p>\n<p>این آگهی باعث متوقف شدن برنامه نمی شود پیغام بالا که توسط PHP صادر شده است برای یاد&zwnj; آوری به برنامه نویس می باشد. اگرچه این کار در PHP مجاز است اما از نظر برنامه نویسی بهتر است قبل از استفاده از متغییر ها آن ها را تعریف کنیم. همچنین می توانیم از متد isset استفاده کنیم. حتی اگر متغییر شما مقدار NULL را داشته باشد بهتر از قبل از استفاده آن را تعریف کنید.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3><a title="آموزش برنامه نویسی و طراحی وب" href="../../" target="_blank">منبع: www.it3du.ir</a></h3>\n<p>&nbsp;</p>', '2018-02-27 13:13:40', 22546897, 'php-logo.png', 37, 103, 1, '2018-02-27 14:45:13'),
(157, 'متد get_instance در codeigniter چیست', 'نحوه عملکرد و دلیل استفاده از متد get_instance در فریمورک کدایگنایدر', 'article,article keywords,article keywords2,keywords2', '<h1>متد get_instance در کدایگنایدر چیست و چگونه کار می کند</h1>\n<p>&nbsp;</p>\n<p>این متد یک آبجکت سراسری از فریمورک را بر می گرداند. یعنی شما پس از فراخوانی این متد می توانید به تمامی نمونه های ایجاد شده در زمانی که فریمورک آغاز شده است را داشته باشید. درواقع یک singleton می باشد. singleton یک design pattern می باشد که یکی از کاربرد و اهداف آن دسترسی کل برنامه به یک آبجکت می باشد. شما در هر کجای برنامه می توانید به این آبجکت دسترسی داشته باشید. فرض کنید یک library در Codeigniter نوشته اید. حالا برای استفاده یک model در این کتابخانه باید از&nbsp; دستور زیر استفاده کنید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>$this-&gt;load-&gt;model("MyModel");</code></pre>\n<p>&nbsp;</p>\n<p>درحالی که فراخوانی مدل به این صورت در کتابخانه مورد نظر امکان پذیر نمی باشد. زیر زمانی که ما در یک Controller از دستور بالا استفاده می کنیم کنترلر از کلاس CI_Controller ارث بری می کند. کلاس کنترلر نوشته شده ما بعد از ارث بری از کلاس CI_Controller کار با مدل، سشن کوکی و دیگر امکانات را برای ما امکان پذیر می کند.</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>class MyController extends CI_Controller {\n\n    function __construct() {\n        parent::__construct();\n    }\n\n    function index() {\n        $this-&gt;load-&gt;view("ViewFile");\n    }\n\n}</code></pre>\n<p>&nbsp;</p>\n<p>ولی برای استفاده از نمونه های ایجاد شده در برنامه و جاهایی غیر از کنترلر که دسترسی آن برای ما امکان پذیر نیست از متد get_instance استفاده می کنیم. مثال زیر را ببینید</p>\n<p>&nbsp;</p>\n<pre class="language-php"><code>class TestLib {\n	\n	function check_session($session_name) {\n		$CI = get_instance();\n		\n		if ($CI-&gt;session-&gt;userdata($session_name)) {\n			return TRUE;\n		}\n		\n		return FALSE;\n		\n	}\n	\n}</code></pre>\n<p>&nbsp;</p>\n<p>در کلاس بالا که در دایرکتوری library موجود در فولدر application قرار دارد ما توانستیم با استفاده از متد get_instance به متغییر session در Codeigniter و در خارج از Controller به آن دسترسی داشته باشیم. به همین صورت می توانید به متغییر های دیگر مانند model، db، input و ... دسترسی پیدا کنید.</p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>\n<h3>منبع: <a title="آموزش برنامه نویسی و طراحی وب" href="../../">it3du.ir</a></h3>\n<p>&nbsp;</p>\n<p>&nbsp;</p>', '2018-05-16 16:35:38', 22546897, 'codeigniter-thumbnail.jpg', 36, 28, 1, '2018-05-23 11:54:29');

-- --------------------------------------------------------

--
-- Table structure for table `author`
--

CREATE TABLE `author` (
  `author_id` int(11) NOT NULL,
  `author_fullname` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `author_email` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `author_password` varchar(32) COLLATE utf8_persian_ci NOT NULL,
  `author_about` varchar(500) COLLATE utf8_persian_ci NOT NULL,
  `author_regdate` datetime NOT NULL,
  `author_status` tinyint(4) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `author`
--

INSERT INTO `author` (`author_id`, `author_fullname`, `author_email`, `author_password`, `author_about`, `author_regdate`, `author_status`) VALUES
(22546897, 'admin fullname', 'admin@admin.ir', '21232f297a57a5a743894a0e4a801fc3', 'nothing', '2016-10-18 18:58:18', 1);

-- --------------------------------------------------------

--
-- Table structure for table `category`
--

CREATE TABLE `category` (
  `category_id` int(11) NOT NULL,
  `category_title` varchar(80) COLLATE utf8_persian_ci NOT NULL,
  `category_keywords` varchar(230) COLLATE utf8_persian_ci DEFAULT NULL,
  `category_description` varchar(230) COLLATE utf8_persian_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `category`
--

INSERT INTO `category` (`category_id`, `category_title`, `category_keywords`, `category_description`) VALUES
(34, 'java', 'java,java category,java tutorial', 'آموزش برنامه نویسی جاوا'),
(35, 'javafx', 'javafx,java fx,جاوا اف ایکس,جاوا FX', 'مقالات با دسته بندی جاوا اف ایکیس. جاوا اف ایکس یک فریمورک جاوا بوده و ...'),
(36, 'codeigniter', 'ci,codeigniter,کدایگنایدر,codeigniter framework,فریمورک کدایگنایدر', 'آموزش برنامه نویسی کدایگنایدر'),
(37, 'php', 'php,php tutorilas,آموزش پی اچ پی,آموزش PHP,زبان برنامه نویسی PHP', 'مقالات با دسته بندی PHP'),
(38, 'algorithm', NULL, NULL);

-- --------------------------------------------------------

--
-- Table structure for table `comment`
--

CREATE TABLE `comment` (
  `comment_id` int(11) NOT NULL,
  `article_id` int(11) NOT NULL,
  `comment_name` varchar(50) COLLATE utf8_persian_ci NOT NULL,
  `comment_date` datetime NOT NULL,
  `comment_url` varchar(80) COLLATE utf8_persian_ci DEFAULT NULL,
  `comment_email` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `comment_content` text COLLATE utf8_persian_ci NOT NULL,
  `comment_ip` varchar(65) COLLATE utf8_persian_ci NOT NULL,
  `comment_status` tinyint(4) NOT NULL DEFAULT '0'
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `comment`
--

INSERT INTO `comment` (`comment_id`, `article_id`, `comment_name`, `comment_date`, `comment_url`, `comment_email`, `comment_content`, `comment_ip`, `comment_status`) VALUES
(2, 121, 'محمد', '2017-09-28 08:45:39', '', 'info@test.ir', 'متن نمونه برای آزمایش', '127.0.0.1', 1),
(3, 135, 'Farnaz', '2017-11-29 15:30:34', '', 'info@test.ir', 'متن نمونه برای آزمایش', '127.0.0.1', 1),
(4, 135, 'behnam', '2017-12-24 11:52:18', '', 'info@test.ir', 'متن نمونه برای آزمایش', '127.0.0.1', 1),
(6, 139, 'میمصادو', '2018-01-22 20:47:25', 'http://test.ir/', 'info@test.ir', 'متن نمونه برای آزمایش', '127.0.0.1', 1),
(8, 136, 'سونیا', '2018-01-30 14:10:57', '', 'info@test.ir', 'متن نمونه برای آزمایش', '127.0.0.1', 1);

-- --------------------------------------------------------

--
-- Table structure for table `tag`
--

CREATE TABLE `tag` (
  `tag_id` int(11) NOT NULL,
  `tags_id` int(11) NOT NULL,
  `article_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `tag`
--

INSERT INTO `tag` (`tag_id`, `tags_id`, `article_id`) VALUES
(294, 117, 120),
(295, 118, 120),
(296, 119, 120),
(297, 120, 120),
(298, 117, 121),
(299, 121, 121),
(300, 122, 121),
(325, 143, 129),
(326, 144, 129),
(327, 145, 129),
(332, 150, 132),
(333, 129, 132),
(334, 151, 132),
(342, 158, 135),
(343, 134, 135),
(344, 159, 135),
(345, 160, 136),
(346, 161, 136),
(347, 129, 136),
(348, 162, 136),
(349, 163, 136),
(350, 164, 137),
(351, 165, 137),
(352, 166, 137),
(353, 167, 137),
(354, 168, 138),
(355, 169, 138),
(356, 170, 138),
(357, 171, 138),
(358, 172, 139),
(359, 173, 139),
(360, 157, 139),
(361, 174, 139),
(392, 198, 146),
(393, 199, 146),
(394, 200, 146),
(395, 201, 147),
(396, 202, 147),
(397, 203, 147),
(398, 204, 147),
(399, 205, 147),
(400, 206, 148),
(401, 207, 148),
(402, 208, 148),
(408, 213, 150),
(409, 214, 150),
(410, 215, 150),
(411, 216, 150),
(412, 217, 150),
(413, 218, 150),
(414, 219, 151),
(415, 220, 151),
(416, 221, 151),
(417, 221, 148),
(418, 222, 152),
(419, 223, 152),
(420, 224, 152),
(421, 225, 152),
(440, 244, 156),
(441, 245, 156),
(442, 246, 156),
(443, 247, 156),
(444, 145, 130),
(445, 248, 130),
(446, 144, 130),
(447, 249, 130),
(448, 250, 130),
(449, 251, 157),
(450, 252, 157),
(451, 253, 157),
(452, 254, 157),
(453, 255, 157);

-- --------------------------------------------------------

--
-- Table structure for table `tags`
--

CREATE TABLE `tags` (
  `tags_id` int(11) NOT NULL,
  `tags_title` varchar(80) COLLATE utf8_persian_ci NOT NULL,
  `tags_description` varchar(230) COLLATE utf8_persian_ci NOT NULL,
  `tags_keywords` varchar(230) COLLATE utf8_persian_ci NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `tags`
--

INSERT INTO `tags` (`tags_id`, `tags_title`, `tags_description`, `tags_keywords`) VALUES
(117, 'آموزش برنامه نویسی جاوا', '', ''),
(118, 'مقدمه ایی بر جاوا', '', ''),
(119, 'جاوا', '', ''),
(120, 'جاوا چیست', '', ''),
(121, 'انواع داده در جاوا', '', ''),
(122, 'data type in java', '', ''),
(123, 'نصب JDK در ویندوز', '', ''),
(124, 'ساختار های کنترلی در جاوا', '', ''),
(125, 'حلقه while در جاوا', '', ''),
(126, 'عملگر ها در جاوا', '', ''),
(127, 'oprations', '', ''),
(128, 'expression', '', ''),
(129, 'آموزش جاوا', '', ''),
(130, 'عبارت ها در جاوا', '', ''),
(131, 'type casting', '', ''),
(132, 'تبدیل نوع داده در جاوا', '', ''),
(133, 'نوع داده اولیه', '', ''),
(134, 'متغییر های مرجع', '', ''),
(135, 'primitive data type', '', ''),
(136, 'reference data type', '', ''),
(137, 'متغییر ها در جاوا', '', ''),
(138, 'ثوابت در جاوا', '', ''),
(139, 'variables در جاوا', '', ''),
(140, 'constant در جاوا', '', ''),
(141, 'بازگشتی در جاوا', '', ''),
(142, 'متد بازگشتی', '', ''),
(143, 'اولین برنامه javaFX', '', ''),
(144, 'جاوا اف ایکس', '', ''),
(145, 'javaFX', '', ''),
(146, 'رسم خط در جاوا', '', ''),
(147, 'رویداد ماوس در جاوا', '', ''),
(148, 'رسم خط با رویداد ماوس در جاوا', '', ''),
(149, 'java', '', ''),
(150, 'به دست آوردن طول صفحه نمایش در جاوا', '', ''),
(151, 'کلاس Toolkit در جاوا', '', ''),
(152, 'cmd', '', ''),
(153, 'کامپایل کد جاوا', '', ''),
(154, 'jdk', '', ''),
(155, 'کامپایل کد جاوا با خط فرمان', '', ''),
(156, 'class in java', '', ''),
(157, 'کلاس ها در جاوا', '', ''),
(158, 'نمونه سازی از کلاس ها', '', ''),
(159, 'دستور new در جاوا', '', ''),
(160, 'construtors', '', ''),
(161, 'سازنده ها در جاوا', '', ''),
(162, 'کانستراکتور چیست', '', ''),
(163, 'فواید کانستراکتور ها', '', ''),
(164, 'اشاره گر this در جاوا', '', ''),
(165, 'مرجع this', '', ''),
(166, 'this در جاوا', '', ''),
(167, 'اشاره گر this چیست', '', ''),
(168, 'رسم اشکال هندسی در جاوا', '', ''),
(169, 'رسم دایره در جاوا', '', ''),
(170, 'رسم مستطیل در جاوا', '', ''),
(171, 'رسم چند ضلعی در جاوا', '', ''),
(172, 'String', '', ''),
(173, 'StringBuffer', '', ''),
(174, 'معرفی چند کلاس کاربردی در جاوا', '', ''),
(193, 'آرایه ها در جاوا', '', ''),
(194, 'Array in java', 'آرایه ها در برنامه نویسی جاوا', 'arrays,array in java,array in programming'),
(195, 'آرایه یک بعدی', '', ''),
(196, 'آرایه دو بعدی', '', ''),
(197, 'کپی کردن آرایه', '', ''),
(198, 'متغییر سراسری در codeigniter', '', ''),
(199, 'تعریف ثابت در codeigniter', '', ''),
(200, 'declare global variable in codeigniter', '', ''),
(201, 'hook', '', ''),
(202, 'هوک', '', ''),
(203, 'هوک در codeigniter', '', ''),
(204, 'مفهوم hook', '', ''),
(205, 'مزایای استفاده از hook', '', ''),
(206, 'eval', '', ''),
(207, 'تابع eval در php', '', ''),
(208, 'اجرای رشته به عنوان کد php', '', ''),
(209, 'الگوریتم', '', ''),
(210, 'الگوریتم جستجوی ترتیبی', '', ''),
(211, 'sequential search', '', ''),
(212, 'برنامه نویسی', '', ''),
(213, 'الگوریتم مرتب سازی', '', ''),
(214, 'الگوریتم مرتب سازی در Java', '', ''),
(215, 'الگوریتم مرتب سازی در C', '', ''),
(216, 'الگریتم مرتب سازی در Python', '', ''),
(217, 'exchange sort', '', ''),
(218, 'الگوریتم مرتب سازی در PHP', '', ''),
(219, 'متد abs در php', '', ''),
(220, 'قدر مطلق عدد در php', '', ''),
(221, 'متد ها در php', '', ''),
(222, 'ساختار حلقه در PHP', '', ''),
(223, 'حلقه while در PHP', '', ''),
(224, 'while', '', ''),
(225, 'while loop in PHP', '', ''),
(226, 'trait در PHP', '', ''),
(227, 'trait چیست', '', ''),
(228, 'trait', '', ''),
(229, 'trait in PHP', '', ''),
(230, 'آرایه', '', ''),
(231, 'array', '', ''),
(232, 'آرایه ها در php', '', ''),
(233, 'arrays in php', '', ''),
(234, 'آرایه های انجمنی', '', ''),
(235, 'آرایه های مختلط', '', ''),
(236, 'آرایه های چند بعدی', '', ''),
(237, 'آرایه های عددی', '', ''),
(238, 'PHP', '', ''),
(239, 'برنامه نویسی PHP', '', ''),
(240, 'شروع برنامه نویسی PHP', '', ''),
(241, 'آموزش برنامه نویسی PHP', '', ''),
(242, 'پی اچ پی', '', ''),
(243, 'آموزش PHP', '', ''),
(244, 'متغییر ها در PHP', '', ''),
(245, 'Variables in PHP', '', ''),
(246, 'data type in PHP', '', ''),
(247, 'نوع داده در PHP', '', ''),
(248, 'javaFX چیست', '', ''),
(249, 'جاوا اف ایکس چیست', '', ''),
(250, 'کاربرد javaFX', '', ''),
(251, 'کدایگنایدر', '', ''),
(252, 'متد get_instance', '', ''),
(253, 'متغیر سوپر گلوبال در کدایگنایدر', '', ''),
(254, 'codeigniter super global object', '', ''),
(255, 'codeigniter core', '', ''),
(256, 'وراثت', '', ''),
(257, 'وراثت در جاوا', '', ''),
(258, 'inheritance', '', ''),
(259, 'شی گرایی', '', ''),
(260, 'object oriented', '', '');

-- --------------------------------------------------------

--
-- Table structure for table `tutorials`
--

CREATE TABLE `tutorials` (
  `tutorials_id` int(11) NOT NULL,
  `tutorials_title` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `tutorials_name` varchar(100) COLLATE utf8_persian_ci NOT NULL,
  `tutorials_keywords` varchar(230) COLLATE utf8_persian_ci DEFAULT NULL,
  `tutorials_description` varchar(230) COLLATE utf8_persian_ci DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `tutorials`
--

INSERT INTO `tutorials` (`tutorials_id`, `tutorials_title`, `tutorials_name`, `tutorials_keywords`, `tutorials_description`) VALUES
(226, 'آموزش برنامه نویسی جاوا', 'java', 'java se,java tutorials', 'آموزش برنامه نویسی جاوا برای اندروید');

-- --------------------------------------------------------

--
-- Table structure for table `tutorial_item`
--

CREATE TABLE `tutorial_item` (
  `tutorial_id` int(11) NOT NULL,
  `tutorials_id` int(11) NOT NULL,
  `article_id` int(11) NOT NULL,
  `tutorial_number` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_persian_ci;

--
-- Dumping data for table `tutorial_item`
--

INSERT INTO `tutorial_item` (`tutorial_id`, `tutorials_id`, `article_id`, `tutorial_number`) VALUES
(16, 226, 120, 1),
(17, 226, 121, 2),
(26, 226, 135, 3),
(27, 226, 136, 4),
(28, 226, 137, 5),
(30, 226, 139, 6);

--
-- Indexes for dumped tables
--

--
-- Indexes for table `answer`
--
ALTER TABLE `answer`
  ADD PRIMARY KEY (`answer_id`);

--
-- Indexes for table `articles`
--
ALTER TABLE `articles`
  ADD PRIMARY KEY (`article_id`);

--
-- Indexes for table `author`
--
ALTER TABLE `author`
  ADD PRIMARY KEY (`author_id`),
  ADD UNIQUE KEY `author_email` (`author_email`);

--
-- Indexes for table `category`
--
ALTER TABLE `category`
  ADD PRIMARY KEY (`category_id`);

--
-- Indexes for table `comment`
--
ALTER TABLE `comment`
  ADD PRIMARY KEY (`comment_id`);

--
-- Indexes for table `tag`
--
ALTER TABLE `tag`
  ADD PRIMARY KEY (`tag_id`);

--
-- Indexes for table `tags`
--
ALTER TABLE `tags`
  ADD PRIMARY KEY (`tags_id`),
  ADD UNIQUE KEY `tags_title` (`tags_title`);

--
-- Indexes for table `tutorials`
--
ALTER TABLE `tutorials`
  ADD PRIMARY KEY (`tutorials_id`),
  ADD UNIQUE KEY `tutorials_name` (`tutorials_name`);

--
-- Indexes for table `tutorial_item`
--
ALTER TABLE `tutorial_item`
  ADD PRIMARY KEY (`tutorial_id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `answer`
--
ALTER TABLE `answer`
  MODIFY `answer_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=4;
--
-- AUTO_INCREMENT for table `articles`
--
ALTER TABLE `articles`
  MODIFY `article_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=158;
--
-- AUTO_INCREMENT for table `category`
--
ALTER TABLE `category`
  MODIFY `category_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=39;
--
-- AUTO_INCREMENT for table `comment`
--
ALTER TABLE `comment`
  MODIFY `comment_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=13;
--
-- AUTO_INCREMENT for table `tag`
--
ALTER TABLE `tag`
  MODIFY `tag_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=459;
--
-- AUTO_INCREMENT for table `tags`
--
ALTER TABLE `tags`
  MODIFY `tags_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=261;
--
-- AUTO_INCREMENT for table `tutorials`
--
ALTER TABLE `tutorials`
  MODIFY `tutorials_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=227;
--
-- AUTO_INCREMENT for table `tutorial_item`
--
ALTER TABLE `tutorial_item`
  MODIFY `tutorial_id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=33;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
